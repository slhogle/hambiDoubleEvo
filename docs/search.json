[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data analysis for the project hambiDoubleEvo",
    "section": "",
    "text": "‡ equal contribution, ◇ Corresponding author and equal contribution\n\n\nTemporal changes in the role of species sorting and evolution determine community dynamics\nHoffman J‡, Hogle SL‡, Hiltunen T◇, Becks L◇ XYZ (2024/5) doi:\n\n\n\nTemporal changes in the role of species sorting and evolution determine community dynamics\nHoffman J‡, Hogle SL‡, Hiltunen T◇, Becks L◇ Research Square(2024) doi: 10.21203/rs.3.rs-4647074/v1"
  },
  {
    "objectID": "index.html#manuscript",
    "href": "index.html#manuscript",
    "title": "Data analysis for the project hambiDoubleEvo",
    "section": "",
    "text": "‡ equal contribution, ◇ Corresponding author and equal contribution\n\n\nTemporal changes in the role of species sorting and evolution determine community dynamics\nHoffman J‡, Hogle SL‡, Hiltunen T◇, Becks L◇ XYZ (2024/5) doi:\n\n\n\nTemporal changes in the role of species sorting and evolution determine community dynamics\nHoffman J‡, Hogle SL‡, Hiltunen T◇, Becks L◇ Research Square(2024) doi: 10.21203/rs.3.rs-4647074/v1"
  },
  {
    "objectID": "index.html#experiment-overview",
    "href": "index.html#experiment-overview",
    "title": "Data analysis for the project hambiDoubleEvo",
    "section": "2 Experiment overview",
    "text": "2 Experiment overview\nThis project is a collaboration between teams at University of Turku in Finland and the University of Konstanz in Germany. The repo contains data from an experiment investigating the relative roles of ecology and evolution in an multitrophic synthetic microbial ecosystem. 24 HAMBI bacterial species were individually grown and coevolved for 100 days (3% vol transfer every 4 days) with the generalist bacterivore Tetrahymena thermophila to generate 6 (replicates A-F) x 24 (species) coevolved bacterial and ciliate populations. Bacteria and ciliates were separated from the coevolution cocultures and bacteria made axenic via freeze-thaw. The 24 predator-coevolved bacterial species were pooled in equal proportions into a “coevolved” prey inoculum. Evolved phenotypically variable ciliates were taken from a 3 year long coevolution experiment (see Cairns 2018, Hogle 2022 Ecol Lett, Hogle 2022 ISME J) and were combined in equal proportions into a “Evolved” predator inoculum. Finally, the 24 clonal/ancestral bacterial species were pooled in equal proportions into a “ancestral” prey incolum and the ancestral Tetrahymena was used as the “ancestral” predator incolum. The inocula were used to start a serial transfer experiment in a full factorial design in six biological replicates (anc prey + anc pred, anc prey + evo pred, evo prey + anc pred, evo prey + evo pred). A no-predator treatment was also used (anc prey + no pred, evo prey + no pred). These evolutionary treatments were serially passaged every 48 hours (30% transfer - 1800 μl to 4.2mL fresh 5% KB medium). The serial transfer microcosms were grown for 60 days after which the experiment was terminated."
  },
  {
    "objectID": "index.html#measurements-and-data-types",
    "href": "index.html#measurements-and-data-types",
    "title": "Data analysis for the project hambiDoubleEvo",
    "section": "3 Measurements and data types",
    "text": "3 Measurements and data types\nThere are many different types of data collected. However, not all data types were collected for all treatment combinations.\n\nBacterial density (OD600) measured from replicates A-F in all treatment combinations at days 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60\nCiliate density (cells/ml) measured from replicates A-F in all treatment combinations at days 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60\nBacterial species frequencies (amplicon counts) were measured from replicates A, C, and E at days 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60\nBacterial species frequencies (amplicon counts) were measured from the “ancestral” and “evolved” inocula used to start the experiment (called “init”). Note this is not measurement from the actual experiment at T0, but a measurement of the inocula.\nWhole genome sequencing data (wgs) for all ancestral/clonal bacterial species (24 total)\nWhole genome sequencing data (wgs) for each coevolved bacterial species population used to inoculate replicates A,C, E (3 x 24 = 72 total).\nMetagenome sequencing data from all evolution treatment combinations, excluding the no predator control conditions (anc prey + no pred, evo prey + no pred) from replicates A, C, E and on days 8, 28, and 60.\nInitial defense traits (resistance to ciliate grazing) were measured by XYZ for:\n\nAll 24 ancestral bacterial species\nAll 24 co-evolved bacterial populations\n\nEvolved defense traits (resistance to ciliate grazing) for:\n\n16 Random clones isolated from 8, 28, and 60 days for each prey/predator/dilution combination\nMeasure OD600 after 48 and 96 hours of growth with and without consumer"
  },
  {
    "objectID": "index.html#data-and-code",
    "href": "index.html#data-and-code",
    "title": "Data analysis for the project hambiDoubleEvo",
    "section": "4 Data and Code",
    "text": "4 Data and Code\n\nData and code here is provided under GPL3. Feel free to use or remix as you see fit.\n\n4.1 Project structure\n\n/R contains R scripts\n/data contains data that has been processed in some way for later use\n/_data_raw contains unprocessed data scraped from compute cluster\n/figs contains figures generated from R scripts"
  },
  {
    "objectID": "index.html#availability",
    "href": "index.html#availability",
    "title": "Data analysis for the project hambiDoubleEvo",
    "section": "4 Availability",
    "text": "4 Availability\nData and code in this GitHub repository (https://github.com/slhogle/hambiDoubleEvo) is provided under GNU AGPL3. Feel free to use or remix as you see fit. The rendered project site is available at https://slhogle.github.io/hambiDoubleEvo/, which has been produced using Quarto notebooks. The content on the rendered site is released under the CC BY 4.0. This repository hosts all code and data for this project including the code necessary to fully recreate the rendered webpage.\nAn archived release of the code here is available from Zenodo: \nRaw sequencing data using in the project is available from NCBI Bioproject PRJNA1179357."
  },
  {
    "objectID": "index.html#reproducibility",
    "href": "index.html#reproducibility",
    "title": "Data analysis for the project hambiDoubleEvo",
    "section": "5 Reproducibility",
    "text": "5 Reproducibility\nThe project uses renv to create reproducible environment to execute the code in this project. See here for a brief overview on collaboration and reproduction of the entire project. To get up and running you can do:\ninstall.packages(\"renv\")\nrenv::restore()"
  },
  {
    "objectID": "R/wgs/01_format_variants.html",
    "href": "R/wgs/01_format_variants.html",
    "title": "Format WGS variants",
    "section": "",
    "text": "Show/hide code\nlibrary(here)\nlibrary(tidyverse)\nlibrary(withr)\nlibrary(fs)\nlibrary(archive)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n# Set up some directories -------------------------------------------------\ndata_raw &lt;- here::here(\"_data_raw\", \"wgs\")\nvcftar &lt;- here::here(data_raw, \"tables.tar.gz\")\n\n# create temporary location to decompress\ntmpdir &lt;- fs::file_temp()\n\n# make processed data directory if it doesn't exist\ndata &lt;- here::here(\"data\", \"wgs\")\nfs::dir_create(data)\n\n# untar directory containing tables \narchive::archive_extract(\n  vcftar,\n  dir = tmpdir,\n  files = NULL,\n  options = character(),\n  strip_components = 0L\n)\n\nvcfdir &lt;- here::here(tmpdir, \"tables\")\n\n# Read variant SnpEff annotations -----------------------------------------\n\nsnpefffiles &lt;- fs::dir_ls(\n  path = vcfdir,\n  all = FALSE,\n  recurse = TRUE,\n  type = \"file\",\n  glob = \"*.snpeff.tsv\",\n  regexp = NULL,\n  invert = FALSE,\n  fail = TRUE\n)\n\nsnpeffslurped &lt;- readr::read_tsv(\n  snpefffiles,\n  skip = 1,\n  col_names = c(\n    \"chrom\",\n    \"pos\",\n    \"ref\",\n    \"alt\",\n    \"filter\",\n    # Annotated using Sequence Ontology terms. Multiple effects can be concatenated using '&'.\n    \"effect\",\n    # A simple estimation of putative impact / deleteriousness : HIGH, MODERATE, LOW, or MODIFIER\n    \"impact\",\n    # gene id from prokka\n    \"locus_tag\",\n    # whether variant is coding or noncoding\n    \"biotype\",\n    # Variant using HGVS notation (DNA level)\n    \"hgvs_c\",\n    # Variant using HGVS notation (Protein level).\n    \"hgvs_p\",\n    # Position in coding bases (one based includes START and STOP codons).\n    \"cds_pos\",\n    # Total number of coding bases (one based includes START and STOP codons).\n    \"cds_len\",\n    # Position in translated product (one based includes START and STOP codons).\n    \"aa_pos\",\n    # Total length of translated product (one based includes START and STOP codons).\n    \"aa_len\"\n  ),\n  col_types = c(\"cdcccccccccdddd\"),\n  id = \"sample\"\n)\n\nsnpeffslurpedfmt &lt;- snpeffslurped %&gt;% \n  # this is weird, but joining on column like filter that contains characters like ';' doesnt work\n  dplyr::select(-filter) %&gt;% \n  mutate(sample = str_extract(sample, \n                              regex(\"(HAMBI_[:digit:]{4}-[:alpha:]-[:alnum:]{3})|(HAMBI_[:digit:]{4}-[:alpha:]-SH-WGS-[:digit:]{3})\"))) %&gt;% \n  separate(sample, into = c(\"strainID\", \"replicate\", \"sample\"), sep=\"-\", extra = \"merge\")\n\n# Read variant frequencies ------------------------------------------------\n\nvarfiles &lt;- fs::dir_ls(\n  path = vcfdir,\n  all = FALSE,\n  recurse = TRUE,\n  type = \"file\",\n  glob = \"*.variants.tsv\",\n  regexp = NULL,\n  invert = FALSE,\n  fail = TRUE\n)\n\nvarslurped &lt;- readr::read_tsv(\n  varfiles,\n  skip = 1,\n  col_names = c(\n    \"chrom\",\n    \"pos\",\n    \"ref\",\n    \"alt\",\n    \"filter\",\n    \"type\",\n    # Allelic depths for the ref and alt alleles in the order listed\n    \"ad\",\n    # Allele fractions of alternate alleles. Excludes filtering\n    \"freq_alt_raw\",\n    # Approximate read depth (reads are filtered if MQ=255 or with bad mates)\n    \"depth_total\",\n    # Count of fragments supporting each allele.\n    \"frag_allele_depth\",\n    # Genotype Quality\n    \"genotype_qual\"\n  ),\n  col_types = c(\"cdccccccccc\"),\n  id = \"sample\"\n)\n\nvarslurpedfmt &lt;- varslurped %&gt;% \n  mutate(sample = str_extract(sample, \n                              regex(\"(HAMBI_[:digit:]{4}-[:alpha:]-[:alnum:]{3})|(HAMBI_[:digit:]{4}-[:alpha:]-SH-WGS-[:digit:]{3})\"))) %&gt;% \n  separate(sample, into = c(\"strainID\", \"replicate\", \"sample\"), sep=\"-\", extra = \"merge\") %&gt;% \n  # taken only first two most abundant alleles\n  separate(ad, into =  c(\"depth_ref\", \"depth_alt\"), \n           sep=\",\", extra=\"drop\") %&gt;% \n  # format depths to numberic\n  mutate(depth_ref = as.numeric(depth_ref), \n         depth_alt = as.numeric(depth_alt)) %&gt;%\n  select(-frag_allele_depth, -genotype_qual) %&gt;% \n  mutate(freq_alt = depth_alt/(depth_ref + depth_alt),\n         freq_ref = 1 - freq_alt) %&gt;% \n  # final format depths to numeric\n  mutate(freq_alt_raw = as.numeric(freq_alt_raw),\n         depth_total = as.numeric(depth_total))\n\n# Read premade annotations -----------------------------------------------------\n\nannotations &lt;- read_rds(here::here(\"_data_raw\", \"shared\", \"annotations_codon_degeneracy.rds\"))\n\n# Combine -----------------------------------------------------------------\n\nfull &lt;- left_join(varslurpedfmt, snpeffslurpedfmt,\n                  by = join_by(strainID, replicate, sample, chrom, pos, ref, alt)) %&gt;%\n  left_join(annotations,\n            by = join_by(strainID, chrom, locus_tag))\n# Write output ------------------------------------------------------------\n\nwrite_rds(full, here::here(data, \"mutect_parsed_annotated.rds\"))\n\n# Clean up ----------------------------------------------------------------\n\n# remove decompressed vcf and tables directory from temp location\nfs::dir_delete(vcfdir)",
    "crumbs": [
      "Population WGS",
      "1. Read and format"
    ]
  },
  {
    "objectID": "R/illumina_v3v4/02_analysis.html",
    "href": "R/illumina_v3v4/02_analysis.html",
    "title": "Analysis of community composition",
    "section": "",
    "text": "Libraries and global variables\n\n\nShow/hide code\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(fishualize)\nlibrary(Polychrome)\nlibrary(withr)\nlibrary(scales)\nlibrary(patchwork)\n\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\nSet up some directories\n\n\nShow/hide code\ndata_raw &lt;- here::here(\"_data_raw\", \"illumina_v3v4\")\n\n# make processed data directory if it doesn't exist\ndata &lt;- here::here(\"data\", \"illumina_v3v4\")\nfigs &lt;- here::here(\"figs\", \"illumina_v3v4\")\n\nfs::dir_create(data)\nfs::dir_create(figs)\n\n\n\n\n\n\nShow/hide code\nmyarplot &lt;- function(.data){\n  cil &lt;- unique(.data$predator_history)\n  bac &lt;- unique(.data$prey_history)\n  \n  mytitle &lt;- case_when(cil == \"anc\"  & bac == \"anc\" ~ \"anc bac + anc cil\",\n                       cil == \"anc\"  & bac == \"evo\" ~ \"evo bac + anc cil\",\n                       cil == \"evo\"  & bac == \"anc\" ~ \"anc bac + evo cil\",\n                       cil == \"evo\"  & bac == \"evo\" ~ \"evo bac + evo cil\",\n                       cil == \"nopredator\" & bac == \"anc\" ~ \"anc bac\",\n                       cil == \"nopredator\" & bac == \"evo\" ~ \"evo bac\",\n                       #cil == \"nopredator\" & bac == \"evo\" ~ \"starting anc bac\",\n                       #cil == \"nopredator\" & bac == \"evo\" ~ \"starting evo bac\"\n  )\n  \n  ggplot(.data) +\n    geom_area(aes(x=time_days, y=f, fill=strainID),\n              color=\"black\", size=0.1) +\n    facet_wrap( ~ replicate, strip.position = \"bottom\") +\n    scale_fill_manual(values = hambi_colors) + \n    scale_y_continuous(limits = c(0,1), expand = c(0, 0), labels = scales::percent) +\n    scale_x_continuous(limits = c(4,60), breaks = c(20, 40, 60)) +\n    labs(x=\"\", y=\"\", fill=\"\", title=mytitle) + \n    theme_bw() + \n    myartheme()\n  \n}\n\nmyartheme &lt;- function(...){\n  theme(\n    panel.spacing.x = unit(0.05,\"line\"),\n    strip.placement = 'outside',\n    strip.background.x = element_blank(),\n    panel.grid = element_blank(),\n    panel.border = element_blank(),\n    panel.background = element_blank(),\n    #axis.text.x = element_blank(),\n    axis.line.x = element_line(color = \"black\"),\n    axis.line.y = element_line(color = \"black\"),\n    legend.title = element_blank(),\n    legend.background = element_blank(),\n    legend.key = element_blank(),\n    ...)\n}\n\nstrain.order &lt;- c(\"HAMBI_2443\", \"HAMBI_3031\", \"HAMBI_1988\", \"HAMBI_3237\", \"HAMBI_0262\", \n                  \"HAMBI_2159\", \"HAMBI_1842\", \"HAMBI_2164\", \"HAMBI_0006\", \"HAMBI_0097\", \n                  \"HAMBI_2494\", \"HAMBI_1299\", \"HAMBI_2160\", \"HAMBI_1279\", \"HAMBI_2792\", \n                  \"HAMBI_1896\", \"HAMBI_0105\", \"HAMBI_0403\", \"HAMBI_1977\", \"HAMBI_1923\", \n                  \"HAMBI_2659\", \"HAMBI_1292\", \"HAMBI_1972\", \"HAMBI_1287\")\n\n\nRead data\n\n\nShow/hide code\ncounts &lt;- read_tsv(here::here(data, \"species_counts.tsv\"))\nmetadf &lt;- read_rds(here::here(\"data\", \"shared\", \"metadata_formatted.rds\"))\n\ncounts_f &lt;- left_join(metadf, counts) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f=count/sum(count)) %&gt;%  \n  ungroup() %&gt;% \n  filter(!is.na(strainID))",
    "crumbs": [
      "Community composition amplicon",
      "2. Analyze and plot"
    ]
  },
  {
    "objectID": "R/illumina_v3v4/02_analysis.html#some-functions",
    "href": "R/illumina_v3v4/02_analysis.html#some-functions",
    "title": "Analysis of community composition",
    "section": "",
    "text": "Show/hide code\nmyarplot &lt;- function(.data){\n  cil &lt;- unique(.data$predator_history)\n  bac &lt;- unique(.data$prey_history)\n  \n  mytitle &lt;- case_when(cil == \"anc\"  & bac == \"anc\" ~ \"anc bac + anc cil\",\n                       cil == \"anc\"  & bac == \"evo\" ~ \"evo bac + anc cil\",\n                       cil == \"evo\"  & bac == \"anc\" ~ \"anc bac + evo cil\",\n                       cil == \"evo\"  & bac == \"evo\" ~ \"evo bac + evo cil\",\n                       cil == \"nopredator\" & bac == \"anc\" ~ \"anc bac\",\n                       cil == \"nopredator\" & bac == \"evo\" ~ \"evo bac\",\n                       #cil == \"nopredator\" & bac == \"evo\" ~ \"starting anc bac\",\n                       #cil == \"nopredator\" & bac == \"evo\" ~ \"starting evo bac\"\n  )\n  \n  ggplot(.data) +\n    geom_area(aes(x=time_days, y=f, fill=strainID),\n              color=\"black\", size=0.1) +\n    facet_wrap( ~ replicate, strip.position = \"bottom\") +\n    scale_fill_manual(values = hambi_colors) + \n    scale_y_continuous(limits = c(0,1), expand = c(0, 0), labels = scales::percent) +\n    scale_x_continuous(limits = c(4,60), breaks = c(20, 40, 60)) +\n    labs(x=\"\", y=\"\", fill=\"\", title=mytitle) + \n    theme_bw() + \n    myartheme()\n  \n}\n\nmyartheme &lt;- function(...){\n  theme(\n    panel.spacing.x = unit(0.05,\"line\"),\n    strip.placement = 'outside',\n    strip.background.x = element_blank(),\n    panel.grid = element_blank(),\n    panel.border = element_blank(),\n    panel.background = element_blank(),\n    #axis.text.x = element_blank(),\n    axis.line.x = element_line(color = \"black\"),\n    axis.line.y = element_line(color = \"black\"),\n    legend.title = element_blank(),\n    legend.background = element_blank(),\n    legend.key = element_blank(),\n    ...)\n}\n\nstrain.order &lt;- c(\"HAMBI_2443\", \"HAMBI_3031\", \"HAMBI_1988\", \"HAMBI_3237\", \"HAMBI_0262\", \n                  \"HAMBI_2159\", \"HAMBI_1842\", \"HAMBI_2164\", \"HAMBI_0006\", \"HAMBI_0097\", \n                  \"HAMBI_2494\", \"HAMBI_1299\", \"HAMBI_2160\", \"HAMBI_1279\", \"HAMBI_2792\", \n                  \"HAMBI_1896\", \"HAMBI_0105\", \"HAMBI_0403\", \"HAMBI_1977\", \"HAMBI_1923\", \n                  \"HAMBI_2659\", \"HAMBI_1292\", \"HAMBI_1972\", \"HAMBI_1287\")\n\n\nRead data\n\n\nShow/hide code\ncounts &lt;- read_tsv(here::here(data, \"species_counts.tsv\"))\nmetadf &lt;- read_rds(here::here(\"data\", \"shared\", \"metadata_formatted.rds\"))\n\ncounts_f &lt;- left_join(metadf, counts) %&gt;% \n  group_by(sample) %&gt;% \n  mutate(f=count/sum(count)) %&gt;%  \n  ungroup() %&gt;% \n  filter(!is.na(strainID))",
    "crumbs": [
      "Community composition amplicon",
      "2. Analyze and plot"
    ]
  },
  {
    "objectID": "R/illumina_v3v4/02_analysis.html#transform-data",
    "href": "R/illumina_v3v4/02_analysis.html#transform-data",
    "title": "Analysis of community composition",
    "section": "3.1 Transform data",
    "text": "3.1 Transform data\nzCompositions has problems with species with &lt; 2 observations so we need to filter these out\n\n\nShow/hide code\nlowstrains &lt;- counts_f %&gt;% \n  filter(!str_detect(condition_prey_pred, \"inoculum\")) %&gt;% \n  filter(!is.na(count)) %&gt;% \n  group_by(strainID) %&gt;% \n  summarize(n_samples = n(),\n            n_gt0 = sum(count &gt; 0),\n            p_gt0 = n_gt0 / n_samples) %&gt;% \n  ungroup()\n\n\nHere we remove strains present in &lt; 50 samples across transfer categories and present in &lt; 20 samples in at least 2/3 transfer categories\n\n\nShow/hide code\nlowstrainsv &lt;- c(\n  \"HAMBI_0097\",\n  \"HAMBI_0262\",\n  \"HAMBI_1842\",\n  \"HAMBI_1988\",\n  \"HAMBI_2443\",\n  \"HAMBI_2792\",\n  \"HAMBI_3031\",\n  \"HAMBI_3237\"\n)\n\n\ntransform to matrix\n\n\nShow/hide code\nmymat &lt;- counts_f %&gt;% \n  filter(!is.na(count)) %&gt;% \n  filter(strainID %nin% lowstrainsv) %&gt;% \n  filter(!str_detect(condition_prey_pred, \"inoculum\")) %&gt;% \n  dplyr::select(sample, strainID, count) %&gt;% \n  # important to arrange by sample as this makes some later joins easier\n  arrange(sample) %&gt;% \n  pivot_wider(names_from = \"strainID\", values_from = \"count\") %&gt;% \n  column_to_rownames(var = \"sample\") %&gt;% \n  data.frame()",
    "crumbs": [
      "Community composition amplicon",
      "2. Analyze and plot"
    ]
  },
  {
    "objectID": "R/illumina_v3v4/02_analysis.html#replace-zeros",
    "href": "R/illumina_v3v4/02_analysis.html#replace-zeros",
    "title": "Analysis of community composition",
    "section": "3.2 Replace zeros",
    "text": "3.2 Replace zeros\nCompositional analysis with the centered log-ratio can’t handle zero values. Some people just replace them with a pseudocount. Another way is to impute them based on various different strategies.\nLiterature:\n\nA field guide for the compositional analysis of any-omics data\n\nSupplemental material\n\nzCompositions — R package for multivariate imputation of left-censored data under a compositional approach\n\nHere we will uses a Geometric Bayesian-multiplicative replacement strategy that preserves the ratios between the non-zero components. The “prop” option returns relative abundances.\n\n\nShow/hide code\nset.seed(12378)\ncomp &lt;- zCompositions::cmultRepl(mymat, method = \"GBM\", output = \"prop\")\n\n\nNo. adjusted imputations:  77",
    "crumbs": [
      "Community composition amplicon",
      "2. Analyze and plot"
    ]
  },
  {
    "objectID": "R/illumina_v3v4/02_analysis.html#calculate-bray-curtis-dissimilarity",
    "href": "R/illumina_v3v4/02_analysis.html#calculate-bray-curtis-dissimilarity",
    "title": "Analysis of community composition",
    "section": "3.3 Calculate Bray-curtis dissimilarity",
    "text": "3.3 Calculate Bray-curtis dissimilarity\n\n\nShow/hide code\nset.seed(12353)\nbray_dist      &lt;- vegan::vegdist(comp, method = \"bray\")\npcoa_ord_bray  &lt;- ape::pcoa(bray_dist)",
    "crumbs": [
      "Community composition amplicon",
      "2. Analyze and plot"
    ]
  },
  {
    "objectID": "R/illumina_v3v4/02_analysis.html#calculate-with-aitchison-distance",
    "href": "R/illumina_v3v4/02_analysis.html#calculate-with-aitchison-distance",
    "title": "Analysis of community composition",
    "section": "3.4 Calculate with Aitchison distance",
    "text": "3.4 Calculate with Aitchison distance\nAitchison distance is the Euclidean distance of the centered log-ratio transform (clr). This distance (unlike Euclidean distance on read counts) has scale invariance, perturbation invariance, permutation invariance and sub-compositional dominance.\n\n\nShow/hide code\nset.seed(12354)\nbalclr     &lt;- compositions::clr(comp)\naitc_dist  &lt;- vegan::vegdist(balclr, method = \"euclidean\")",
    "crumbs": [
      "Community composition amplicon",
      "2. Analyze and plot"
    ]
  },
  {
    "objectID": "R/illumina_v3v4/02_analysis.html#compare-aitchison-distance-with-clr",
    "href": "R/illumina_v3v4/02_analysis.html#compare-aitchison-distance-with-clr",
    "title": "Analysis of community composition",
    "section": "3.5 Compare Aitchison distance with CLR",
    "text": "3.5 Compare Aitchison distance with CLR\nWhen the Aitchison distance is used in Principle co-ordinate Analysis (PCoA) it is equivalent to standard Principle Component Analyis (PCA) on the clr transformed data\n\n\nShow/hide code\nset.seed(12355)\npcoa_ord_aitc  &lt;- ape::pcoa(aitc_dist)\npca_ord_aitc   &lt;- prcomp(balclr)\n\n\nFor example, these ordinations are the same, just that Axis2 is the mirrorimage between. Since the rotation is arbitrary this does not matter.\n\nShow/hide code\nplot(pcoa_ord_aitc$vectors)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Plot of Principal Coordinate Analysis (PCoA) done in the Aitchison geometry of the simplex (i.e. PCoA on the euclidean distance of the centered log-ratio transform species compositions).\n\n\n\n\nShow/hide code\nplot(pca_ord_aitc$x)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Plot of Principal Component Analysis (PCA) done in the Aitchison geometry of the simplex (i.e. PCA on the centered log-ratio transform species compositions). Notice that the PCoA using the euclidean distance of centered log-ratio transformed species frequencies is equivalent to the PCA directly using clr-transformed values in Figure 3.",
    "crumbs": [
      "Community composition amplicon",
      "2. Analyze and plot"
    ]
  },
  {
    "objectID": "R/illumina_v3v4/02_analysis.html#environment-vectors",
    "href": "R/illumina_v3v4/02_analysis.html#environment-vectors",
    "title": "Analysis of community composition",
    "section": "3.6 Environment vectors",
    "text": "3.6 Environment vectors\nleft_join with metadata\n\n\nShow/hide code\npca2plot &lt;- data.frame(pca_ord_aitc$x) %&gt;% \n  rownames_to_column(var = \"sample\") %&gt;% \n  left_join(metadf) %&gt;% \n  arrange(sample) %&gt;% \n  mutate(expcombo=interaction(condition_prey_pred, time_days, sep = \"_\"))\n\n\nAbout 85% of variance explained in first 5 PCs\n\n\nShow/hide code\npca_ord_aitc_importance &lt;- as.data.frame(summary(pca_ord_aitc)$importance) %&gt;% \n  rownames_to_column(var = \"parameter\")\n\npca_ord_aitc_importance\n\n\n\n  \n\n\n\nEnvironmental/experimental variables associated with ordinatoion\n\n\nShow/hide code\nef &lt;-\n  envfit(\n    pca_ord_aitc ~ prey_history + predator_history + ciliates_ml + time_days,\n    data = semi_join(metadf, dplyr::select(pca2plot, sample)),\n    na.rm = T,\n    choices = c(1, 2)\n  )\n\n\n\nShow/hide code\nbiplot(pca_ord_aitc, choices=c(1,2), labSize=0)\nplot(ef)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Environmental vectors plotted onto ordination in Figure 4\n\n\n\n\n3.6.1 Significance of the environmental covariates\n\n\nShow/hide code\nef\n\n\n\n***VECTORS\n\n                PC1     PC2     r2 Pr(&gt;r)    \nciliates_ml 0.84491 0.53492 0.1262  0.001 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\nPermutation: free\nNumber of permutations: 999\n\n***FACTORS:\n\nCentroids:\n                        PC1     PC2\nprey_historyanc      4.3571 -0.5277\nprey_historyevo     -3.0257  1.4454\npredator_historyanc  1.1182 -1.1211\npredator_historyevo  0.2132  2.0388\ntime_days4          -0.8610 -4.2785\ntime_days8           0.8755 -1.0156\ntime_days12          1.1134  0.1314\ntime_days16          1.2332  0.0357\ntime_days20         -0.0521  0.3658\ntime_days24          1.8596  1.4475\ntime_days28          1.5366  1.0170\ntime_days32          0.4066  0.7041\ntime_days36          0.9413  1.1857\ntime_days40          0.4137  1.0675\ntime_days44          0.4505  1.2408\ntime_days48          0.2291  1.2173\ntime_days52          0.9245  1.6736\ntime_days56          0.8231  0.6831\ntime_days60          0.0920  1.4073\n\nGoodness of fit:\n                     r2 Pr(&gt;r)    \nprey_history     0.5357  0.001 ***\npredator_history 0.0991  0.001 ***\ntime_days        0.0911  0.246    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\nPermutation: free\nNumber of permutations: 999\n\n24 observations deleted due to missingness\n\n\n\n\nShow/hide code\ncon_scrs &lt;- as.data.frame(scores(ef, display = \"vectors\")) %&gt;%\n  rownames_to_column(var = \"var\") %&gt;% tibble()\n\nfct_scrs &lt;- as.data.frame(scores(ef, display = \"factors\")) %&gt;% \n  rownames_to_column(var = \"var\") %&gt;%  tibble()\n\nscale_factor &lt;- 15\n\n\n\n\n3.6.2 Plot with prey history highlighted\n\n\nShow/hide code\nppca &lt;- ggplot(pca2plot) +\n  geom_point(aes(\n    x = PC1,\n    y = PC2,\n    color = prey_history,\n    shape = predator_history), size=3 ) +\n  geom_segment(data = con_scrs,\n               aes(x = 0, xend = PC1*scale_factor, y = 0, yend = PC2*scale_factor),\n               arrow = arrow(length = unit(0.25, \"cm\")), colour = \"black\") +\n  geom_text_repel(data = con_scrs, aes(x = PC1*scale_factor, y = PC2*scale_factor, label = var),\n                  size = 3) +\n  labs(x = paste0(\"PC1 (\", round(pca_ord_aitc_importance[2,2]*100, 1),\"%)\"), \n       y = paste0(\"PC2 (\", round(pca_ord_aitc_importance[2,3]*100, 1),\"%)\")) +\n  stat_ellipse(aes(x = PC1, y = PC2, color = prey_history)) + \n  coord_fixed() +\n  scale_color_manual(values = c(\"#88CCEE\", \"#CC6677\")) +\n  scale_shape_manual(values = c(1, 0, 15)) +\n  theme_bw() +\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Plot of principal component analysis (PCA) done in the Aitchison geometry of the simplex (i.e. centered log-ratio transform species compositions). Color shows evolutionary history of the prey and shape shows evolutionary history of the predator. Arrows and ellipses depict statistically significant (P &lt; 0.05) experimental variables (continuous and categorical, resp) fit to the ordination axes via regression (vegan::envfit) and projected onto the ordination plot. Significance is assessed by permutation.\n\n\n\n\n\n3.6.3 Plot with predator history highlighted\n\nShow/hide code\nggplot(pca2plot) +\n  geom_point(aes(\n    x = PC1,\n    y = PC2,\n    color = predator_history,\n    shape = prey_history), size=3 ) +\n  geom_segment(data = con_scrs,\n               aes(x = 0, xend = PC1*scale_factor, y = 0, yend = PC2*scale_factor),\n               arrow = arrow(length = unit(0.25, \"cm\")), colour = \"black\") +\n  geom_text_repel(data = con_scrs, aes(x = PC1*scale_factor, y = PC2*scale_factor, label = var),\n                  size = 3) +\n  labs(x = paste0(\"PC1 (\", round(pca_ord_aitc_importance[2,2]*100, 1),\"%)\"), \n       y = paste0(\"PC2 (\", round(pca_ord_aitc_importance[2,3]*100, 1),\"%)\")) +\n  stat_ellipse(aes(x = PC1, y = PC2, color = predator_history)) + \n  coord_fixed() +\n  theme_bw() +\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: As in Figure 6 but with predator evolutionary history highlighted in color.\n\n\n\nThe evolved predator seems to “tighten” up the variation and make samplles with ancestral prey “look” more like the samples with evolved prey\n\n\n3.6.4 PERMANOVA\nPERMANOVA suggests significant effect of predator and prey evolutionary history\n\n\nShow/hide code\nset.seed(45781)\nadonis2(aitc_dist ~ pca2plot$prey_history + pca2plot$predator_history,\n       permutations = 1e3)\n\n\n\n  \n\n\n\nCheck for homogeneity of variance between these two categories. Suggests that they are different although maybe not by very much…\n\n\nShow/hide code\nset.seed(45782)\nbdprey &lt;- betadisper(aitc_dist, pca2plot$prey_history)\npermutest(bdprey)\n\n\n\nPermutation test for homogeneity of multivariate dispersions\nPermutation: free\nNumber of permutations: 999\n\nResponse: Distances\n           Df Sum Sq Mean Sq      F N.Perm Pr(&gt;F)   \nGroups      1  38.61  38.613 9.4672    999  0.002 **\nResiduals 202 823.88   4.079                        \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\nShow/hide code\nset.seed(45783)\nbdpred &lt;- betadisper(aitc_dist, pca2plot$predator_history)\npermutest(bdpred)\n\n\n\nPermutation test for homogeneity of multivariate dispersions\nPermutation: free\nNumber of permutations: 999\n\nResponse: Distances\n           Df Sum Sq Mean Sq     F N.Perm Pr(&gt;F)    \nGroups      2 136.53  68.263 34.83    999  0.001 ***\nResiduals 201 393.94   1.960                        \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1",
    "crumbs": [
      "Community composition amplicon",
      "2. Analyze and plot"
    ]
  },
  {
    "objectID": "R/illumina_v3v4/02_analysis.html#geometric-analysis-of-temporal-trajectories-in-pca",
    "href": "R/illumina_v3v4/02_analysis.html#geometric-analysis-of-temporal-trajectories-in-pca",
    "title": "Analysis of community composition",
    "section": "3.7 Geometric analysis of temporal trajectories in PCA",
    "text": "3.7 Geometric analysis of temporal trajectories in PCA\nFunction to calculate euclidean distance between points\n\n\nShow/hide code\neuclidean_dist &lt;- function(x1, x2, y1, y2){\n  sqrt((x1 - x2)^2 + (y1 - y2)^2)\n}\n\n\n\n\nShow/hide code\neucdist &lt;- pca2plot %&gt;% \n  filter(prey_history != \"none\") %&gt;%\n  filter(predator_history != \"nopredator\") %&gt;% \n  dplyr::select(PC1, PC2, replicate, prey_history, predator_history, time_days) %&gt;% \n  arrange(replicate, prey_history, predator_history, time_days) %&gt;% \n  group_by(replicate, prey_history, predator_history) %&gt;% \n  mutate(d = euclidean_dist(PC1, lag(PC1), PC2, lag(PC2)),\n         range = paste0(lag(time_days),\"-\",time_days)) %&gt;%\n  mutate(range = forcats::fct_reorder(range, as.numeric(as.character((time_days))))) %&gt;%\n  filter(range != \"NA-4\")\n\nwrite_tsv(eucdist, here::here(data, \"aitchison_pca_distances.tsv\"))\n\n\n\nShow/hide code\nggplot(eucdist) +\n  geom_line(aes(x = range, y = d, color = replicate, group=replicate)) +\n  labs(x = \"Time range (days)\", y = \"Euclidean distance between days\") +\n  scale_x_discrete(guide = guide_axis(angle = 45)) +\n  facet_grid(prey_history ~ predator_history, labeller = label_both, scales = \"free_x\") +\n  theme_bw() +\n  theme(\n    legend.position = \"bottom\",\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n    panel.grid = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Geometric analysis of community trajectories based on PCA. Segment lengths between consecutive sampling days in the two PCA dimensions were calculated and plotted chronologically for each biological replicate in each treatment combination. As sampling intervals were of equal duration (except day 16 - 24), segment length represents relative speed of compositional change.",
    "crumbs": [
      "Community composition amplicon",
      "2. Analyze and plot"
    ]
  },
  {
    "objectID": "R/metagenome/01_format_variants.html",
    "href": "R/metagenome/01_format_variants.html",
    "title": "Format metagenome variants",
    "section": "",
    "text": "Libraries and global variables\n\n\nShow/hide code\nlibrary(here)\nlibrary(tidyverse)\nlibrary(Polychrome)\nlibrary(withr)\nlibrary(fs)\nlibrary(archive)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\nSet up some directories\n\n\nShow/hide code\ndata_raw &lt;- here::here(\"_data_raw\", \"metagenome\")\nshared &lt;- here::here(\"_data_raw\", \"shared\")\nvcftar &lt;- here::here(data_raw, \"tables.tar.gz\")\ncovtar &lt;- here::here(data_raw, \"coverage.tar.gz\")\n\n# create temporary location to decompress\ntmpdir &lt;- fs::file_temp()\n\n# make processed data directory if it doesn't exist\ndata &lt;- here::here(\"data\", \"metagenome\")\nfs::dir_create(data)\n\n\n\n\n\n\nShow/hide code\n# untar directory containing variant tables \narchive::archive_extract(\n  vcftar,\n  dir = tmpdir,\n  files = NULL,\n  options = character(),\n  strip_components = 0L\n)\n\nvcfdir &lt;- here::here(tmpdir, \"tables\")\n\n# untar directory containing variant tables \narchive::archive_extract(\n  covtar,\n  dir = tmpdir,\n  files = NULL,\n  options = character(),\n  strip_components = 0L\n)\n\ncovdir &lt;- here::here(tmpdir, \"coverage\")",
    "crumbs": [
      "Metagenome sequencing",
      "1. Read and format"
    ]
  },
  {
    "objectID": "R/metagenome/01_format_variants.html#untar-and-decompress",
    "href": "R/metagenome/01_format_variants.html#untar-and-decompress",
    "title": "Format metagenome variants",
    "section": "",
    "text": "Show/hide code\n# untar directory containing variant tables \narchive::archive_extract(\n  vcftar,\n  dir = tmpdir,\n  files = NULL,\n  options = character(),\n  strip_components = 0L\n)\n\nvcfdir &lt;- here::here(tmpdir, \"tables\")\n\n# untar directory containing variant tables \narchive::archive_extract(\n  covtar,\n  dir = tmpdir,\n  files = NULL,\n  options = character(),\n  strip_components = 0L\n)\n\ncovdir &lt;- here::here(tmpdir, \"coverage\")",
    "crumbs": [
      "Metagenome sequencing",
      "1. Read and format"
    ]
  },
  {
    "objectID": "R/metagenome/01_format_variants.html#coverage-data",
    "href": "R/metagenome/01_format_variants.html#coverage-data",
    "title": "Format metagenome variants",
    "section": "2.1 Coverage data",
    "text": "2.1 Coverage data\n\n\nShow/hide code\ncovfiles &lt;- fs::dir_ls(\n  path = covdir,\n  all = FALSE,\n  recurse = TRUE,\n  type = \"file\",\n  glob = \"*.coverage.tsv\",\n  regexp = NULL,\n  invert = FALSE,\n  fail = TRUE\n)\n\ncovslurped &lt;- readr::read_tsv(\n  covfiles,\n  skip = 1,\n  col_names = c(\n    \"scaffold\",\n    \"mean\",\n    \"trimmed_mean\",\n    \"covered_fraction\",\n    \"covered_bases\",\n    \"variance\",\n    \"length\",\n    \"read_count\",\n    \"reads_per_base\"\n  ),\n  col_types = \"cdddddddd\",\n  id = \"file_name\"\n)\n\ncovslurpedfmt &lt;- covslurped %&gt;%\n  mutate(sample = str_extract(file_name, \"SH-MET-[:digit:]{3}\"),\n         strainID   = str_extract(file_name, \"HAMBI_[:digit:]{4}\")) %&gt;%\n  dplyr::select(-file_name) %&gt;%\n  relocate(strainID, sample)\n\ncovslurpedfmtflt &lt;- covslurpedfmt %&gt;%\n  mutate(bamname = paste0(strainID,\"-\",sample)) %&gt;%\n  # exclude species with trimmed mean (Dt) &lt; 5\n  mutate(FILTER = if_else(trimmed_mean &gt;= 5, FALSE, TRUE))\n\nwrite_tsv(covslurpedfmtflt, here::here(data, \"coverage.tsv\"))\n\n# cleanup\nfs::dir_delete(covdir)\n\n\n\n\nShow/hide code\ncovslurpedfmtflt &lt;- read_tsv(here::here(data, \"coverage.tsv\"))",
    "crumbs": [
      "Metagenome sequencing",
      "1. Read and format"
    ]
  },
  {
    "objectID": "R/metagenome/01_format_variants.html#variants",
    "href": "R/metagenome/01_format_variants.html#variants",
    "title": "Format metagenome variants",
    "section": "2.2 Variants",
    "text": "2.2 Variants\n\n2.2.1 SnpEff annotations\n\n\nShow/hide code\nsnpefffiles &lt;- fs::dir_ls(\n  path = vcfdir,\n  all = FALSE,\n  recurse = TRUE,\n  type = \"file\",\n  glob = \"*.snpeff.tsv\",\n  regexp = NULL,\n  invert = FALSE,\n  fail = TRUE\n)\n\nsnpeffslurped &lt;- readr::read_tsv(\n  snpefffiles,\n  skip = 1,\n  col_names = c(\n    \"chrom\",\n    \"pos\",\n    \"ref\",\n    \"alt\",\n    \"filter\",\n    # Annotated using Sequence Ontology terms. Multiple effects can be concatenated using '&'.\n    \"effect\",\n    # A simple estimation of putative impact / deleteriousness : HIGH, MODERATE, LOW, or MODIFIER\n    \"impact\",\n    # gene id from prokka\n    \"locus_tag\",\n    # whether variant is coding or noncoding\n    \"biotype\",\n    # Variant using HGVS notation (DNA level)\n    \"hgvs_c\",\n    # Variant using HGVS notation (Protein level).\n    \"hgvs_p\",\n    # Position in coding bases (one based includes START and STOP codons).\n    \"cds_pos\",\n    # Total number of coding bases (one based includes START and STOP codons).\n    \"cds_len\",\n    # Position in translated product (one based includes START and STOP codons).\n    \"aa_pos\",\n    # Total length of translated product (one based includes START and STOP codons).\n    \"aa_len\"\n  ),\n  col_types = c(\"cdcccccccccdddd\"),\n  id = \"sample\"\n)\n\nsnpeffslurpedfmt &lt;- snpeffslurped %&gt;% \n  # this is weird, but joining on column like filter that contains characters like ';' doesnt work\n  dplyr::select(-filter) %&gt;% \n  mutate(sample = str_extract(sample, \n                              regex(\"(HAMBI_[:digit:]{4}-SH-MET-[:digit:]{3})\"))) %&gt;% \n  separate(sample, into = c(\"strainID\", \"sample\"), sep=\"-\", extra = \"merge\")\n\n\n\n\n2.2.2 Allele frequencies\n\n\nShow/hide code\nvarfiles &lt;- fs::dir_ls(\n  path = vcfdir,\n  all = FALSE,\n  recurse = TRUE,\n  type = \"file\",\n  glob = \"*.variants.tsv\",\n  regexp = NULL,\n  invert = FALSE,\n  fail = TRUE\n)\n\nvarslurped &lt;- readr::read_tsv(\n  varfiles,\n  skip = 1,\n  col_names = c(\n    \"chrom\",\n    \"pos\",\n    \"ref\",\n    \"alt\",\n    \"filter\",\n    \"type\",\n    # Allelic depths for the ref and alt alleles in the order listed\n    \"ad\",\n    # Allele fractions of alternate alleles. Excludes filtering\n    \"freq_alt_raw\",\n    # Approximate read depth (reads are filtered if MQ=255 or with bad mates)\n    \"depth_total\",\n    # Count of fragments supporting each allele.\n    \"frag_allele_depth\",\n    # Genotype Quality\n    \"genotype_qual\"\n  ),\n  col_types = c(\"cdccccccccc\"),\n  id = \"sample\"\n)\n\nvarslurpedfmt &lt;- varslurped %&gt;% \n  mutate(sample = str_extract(sample, \n                              regex(\"(HAMBI_[:digit:]{4}-SH-MET-[:digit:]{3})\"))) %&gt;% \n  separate(sample, into = c(\"strainID\", \"sample\"), sep=\"-\", extra = \"merge\") %&gt;% \n  # taken only first two most abundant alleles\n  separate(ad, into =  c(\"depth_ref\", \"depth_alt\"), \n           sep=\",\", extra=\"drop\") %&gt;% \n  # format depths to numberic\n  mutate(depth_ref = as.numeric(depth_ref), \n         depth_alt = as.numeric(depth_alt)) %&gt;%\n  select(-frag_allele_depth, -genotype_qual) %&gt;% \n  mutate(freq_alt = depth_alt/(depth_ref + depth_alt),\n         freq_ref = 1 - freq_alt) %&gt;% \n  # final format depths to numeric\n  mutate(freq_alt_raw = as.numeric(freq_alt_raw),\n         depth_total = as.numeric(depth_total))\n\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `freq_alt_raw = as.numeric(freq_alt_raw)`.\nCaused by warning:\n! NAs introduced by coercion\n\n\n\n\n2.2.3 Clean up tmp directories\n\n\nShow/hide code\n# remove decompressed vcf and tables directory from temp location\nfs::dir_delete(vcfdir)",
    "crumbs": [
      "Metagenome sequencing",
      "1. Read and format"
    ]
  },
  {
    "objectID": "R/metagenome/01_format_variants.html#mutations-from-wgs-analysis",
    "href": "R/metagenome/01_format_variants.html#mutations-from-wgs-analysis",
    "title": "Format metagenome variants",
    "section": "2.3 Mutations from WGS analysis",
    "text": "2.3 Mutations from WGS analysis\n\n\nShow/hide code\nwgs_freq &lt;- read_tsv(here::here(\"data\", \"wgs\", \"wgsvars_filt_mb_nonsyn.tsv\"))",
    "crumbs": [
      "Metagenome sequencing",
      "1. Read and format"
    ]
  },
  {
    "objectID": "R/metagenome/01_format_variants.html#annotations",
    "href": "R/metagenome/01_format_variants.html#annotations",
    "title": "Format metagenome variants",
    "section": "2.4 Annotations",
    "text": "2.4 Annotations\n\n\nShow/hide code\n#annotations &lt;- read_rds(here::here(data_raw, \"annotations_codon_degeneracy.rds\"))\nmgefinder &lt;- read_tsv(here::here(shared, \"MGE_finder_HAMBI_combined.tsv\"))\ngenomad &lt;- read_tsv(here::here(shared, \"genomad_HAMBI_combined.tsv\")) %&gt;% \n  # exclude very large plasmids over 1Mbp from the filtering\n  filter((end - start) &lt; 1000000)",
    "crumbs": [
      "Metagenome sequencing",
      "1. Read and format"
    ]
  },
  {
    "objectID": "R/metagenome/01_format_variants.html#exclude-regions-with-mobile-elements-in-metagenomes",
    "href": "R/metagenome/01_format_variants.html#exclude-regions-with-mobile-elements-in-metagenomes",
    "title": "Format metagenome variants",
    "section": "3.1 Exclude regions with mobile elements in metagenomes",
    "text": "3.1 Exclude regions with mobile elements in metagenomes\n\n\nShow/hide code\nmgvars_filt_mb &lt;- mgvars %&gt;% \n  left_join(mgefinder, by = join_by(strainID, chrom), relationship = \"many-to-many\") %&gt;% \n  filter(!(pos &gt;= start & pos &lt;= end)) %&gt;% \n  dplyr::select(-name, -start, -end, -prediction_tool) %&gt;% \n  distinct() %&gt;% \n  left_join(genomad, by = join_by(strainID, chrom), relationship = \"many-to-many\") %&gt;% \n  filter(!(pos &gt;= start & pos &lt;= end)) %&gt;% \n  dplyr::select(-name, -start, -end, -prediction_tool) %&gt;% \n  distinct()",
    "crumbs": [
      "Metagenome sequencing",
      "1. Read and format"
    ]
  },
  {
    "objectID": "R/metagenome/01_format_variants.html#filter-wgs-on-species-only-included-in-metag",
    "href": "R/metagenome/01_format_variants.html#filter-wgs-on-species-only-included-in-metag",
    "title": "Format metagenome variants",
    "section": "3.2 Filter WGS on species only included in metaG",
    "text": "3.2 Filter WGS on species only included in metaG\n\n\nShow/hide code\nwgs_filt_mb &lt;- wgs_freq %&gt;% \n  filter(strainID %in% sps) %&gt;% \n  mutate(anc = \"anc\", evo = \"evo\") %&gt;% \n  pivot_longer(cols = c(anc, evo), names_to = \"predator_history\", values_to = \"tmp\") %&gt;%  select(-tmp) %&gt;% \n  mutate(prey_history = \"evo\", \n         transfer_category = \"hi\",\n         transfer_volume_ul = 1800,\n         time_days = 0)",
    "crumbs": [
      "Metagenome sequencing",
      "1. Read and format"
    ]
  },
  {
    "objectID": "R/metagenome/01_format_variants.html#combine-wgs-and-metag",
    "href": "R/metagenome/01_format_variants.html#combine-wgs-and-metag",
    "title": "Format metagenome variants",
    "section": "3.3 Combine WGS and metaG",
    "text": "3.3 Combine WGS and metaG\nThis includes all variants - both amino acid changing and non-changing\n\n\nShow/hide code\nfreq_mg_wgs &lt;- left_join(mgvars_filt_mb, \n                         read_tsv(here::here(data, \"metadata.tsv\"))) %&gt;% \n  filter(transfer_category == \"hi\") %&gt;% \n  bind_rows(wgs_filt_mb) %&gt;% \n  mutate(pos = as.numeric(pos),\n         depth_total = as.numeric(depth_total)) %&gt;% \n  select(-hgvs_c, -aa_pos, -aa_len)\n\n\nRows: 36 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (5): sample, transfer_category, replicate, prey_history, predator_history\ndbl (2): transfer_volume_ul, time_days\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nJoining with `by = join_by(sample)`",
    "crumbs": [
      "Metagenome sequencing",
      "1. Read and format"
    ]
  },
  {
    "objectID": "R/metagenome/01_format_variants.html#expand-grid-for-variants",
    "href": "R/metagenome/01_format_variants.html#expand-grid-for-variants",
    "title": "Format metagenome variants",
    "section": "3.4 Expand grid for variants",
    "text": "3.4 Expand grid for variants\nMake a dataframe where all times/species/replicates/genomic position/experimental conditions are present\n\n\nShow/hide code\nvars_united &lt;- freq_mg_wgs %&gt;% \n  select(chrom, pos, ref, alt) %&gt;% \n  distinct() %&gt;% \n  unite(\"combo\", c(chrom, pos, ref, alt), sep = \"|\")\n\ntimes_full &lt;- expand_grid(combo = vars_united$combo, \n              time_days = c(0, 8, 28, 60), \n              replicate = c(\"A\", \"C\", \"E\"),\n              prey_history = c(\"anc\", \"evo\"),\n              predator_history = c(\"anc\", \"evo\")) %&gt;% \n  separate_wider_delim(combo, delim = \"|\", names = c(\"chrom\", \"pos\", \"ref\", \"alt\")) %&gt;% \n  mutate(pos = as.numeric(pos),\n         transfer_category = \"hi\",\n         transfer_volume_ul = 1800)",
    "crumbs": [
      "Metagenome sequencing",
      "1. Read and format"
    ]
  },
  {
    "objectID": "R/metagenome/01_format_variants.html#format-metagenome-coverage-data",
    "href": "R/metagenome/01_format_variants.html#format-metagenome-coverage-data",
    "title": "Format metagenome variants",
    "section": "3.5 Format metagenome coverage data",
    "text": "3.5 Format metagenome coverage data\n\n\nShow/hide code\nmg_cov &lt;- covslurpedfmtflt %&gt;%  \n  filter(strainID %in% sps) %&gt;% \n  left_join(read_tsv(here::here(data, \"metadata.tsv\"))) %&gt;% \n  filter(transfer_category == \"hi\") %&gt;% \n  # samples with trimmed mean coverage &gt;=10 with over 99% of genome covered\n  # are to be trusted\n  mutate(cov_thresh_met = if_else(trimmed_mean &gt;= 10 & covered_fraction &gt; 0.99, 1, 0)) %&gt;% \n  select(sample, strainID, chrom=scaffold, trimmed_mean, covered_fraction, transfer_category:cov_thresh_met)",
    "crumbs": [
      "Metagenome sequencing",
      "1. Read and format"
    ]
  },
  {
    "objectID": "R/metagenome/02_parallelism.html",
    "href": "R/metagenome/02_parallelism.html",
    "title": "Metagenome genetic parallelism",
    "section": "",
    "text": "Libraries and global variables\n\n\nShow/hide code\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(patchwork)\nlibrary(ggforce)\nlibrary(latex2exp)\nlibrary(vctrs)\n\nsource(here::here(\"R\", \"utils_generic.R\"))\nsource(here::here(\"R\", \"metagenome\", \"utils_parallelism.R\"))\n\n\nSet up some directories\n\n\nShow/hide code\ndata_raw &lt;- here::here(\"_data_raw\", \"metagenome\")\ndata &lt;- here::here(\"data\", \"metagenome\")\nshared &lt;- here::here(\"_data_raw\", \"shared\")\nfigs &lt;- here::here(\"figs\", \"metagenome\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\nfs::dir_create(figs)",
    "crumbs": [
      "Metagenome sequencing",
      "2. Parallelism analysis"
    ]
  },
  {
    "objectID": "R/metagenome/02_parallelism.html#nucleotide-parallelism-by-treatment",
    "href": "R/metagenome/02_parallelism.html#nucleotide-parallelism-by-treatment",
    "title": "Metagenome genetic parallelism",
    "section": "3.1 Nucleotide parallelism by treatment",
    "text": "3.1 Nucleotide parallelism by treatment\nHere we will do the estimation separately for each species \\(\\times\\) treatment combination.\n\n\nShow/hide code\nnuc_survival &lt;- mgvars_filt_mb %&gt;%\n  dplyr::select(strainID, prey_history, predator_history, pos, ref, alt, replicate) %&gt;% \n  # multiplicity = number of replicate populations each unique mutation is\n  # observed in\n  summarize(m = n_distinct(replicate), .by = c(strainID, prey_history, predator_history, pos, ref, alt)) %&gt;%\n  # now calculate the total number of mutations across all replicates so we need\n  # to ungroup by mutation position/alt allele but because we still want to\n  # determine this value by treatment category we keep the treatment category\n  # grouping. However, this should be changed if you want to for example average\n  # over all the treatment conditions on a species basis\n  group_by(strainID, prey_history, predator_history) %&gt;%\n  count(m, name = \"m_count\") %&gt;%\n  mutate(n = m * m_count,\n         Ntot = sum(n),\n         perc = n / Ntot * 100) %&gt;%\n  left_join(genome_len, by = join_by(strainID)) %&gt;%\n  arrange(cur_group_id(), desc(m)) %&gt;%\n  #  dpois() tells the probability mass at a given number of counts. Here we\n  #  want to get the probability of observing n mutations with multiplicity\n  #  = mi (i.e. the counts of mi in the observed data). We assume that\n  #  mutations independently occur on the genome of size Ltot at a rate of\n  #  lambda = Ntot/Ltot and that generally the events are rare. Thus this\n  #  situation can be modeled by the Poisson distribution. We can get the\n  #  binned number of mutations per level of multiplicity m by multiplying\n  #  the probability by the length of the genome and the binned mutations\n  #  divided by the total number of mutations.\n  mutate(m_count_expected = cumsum((m_count / Ntot) *\n                                     total_len *\n                                     dpois(m, lambda = Ntot / total_len))) %&gt;%\n  dplyr::select(-num_contigs) %&gt;%\n  relocate(m, n, Ntot, perc, m_count, m_count_expected) %&gt;%\n  ungroup()\n\n# setup for plotting\nnuc_survival_plot &lt;- nuc_survival %&gt;% \n  group_by(strainID, prey_history, predator_history) %&gt;% \n  # when there is only one multiplicity observed for a mutation filter such\n  # that the multiplicty of that mutation must be greater than one.\n  # Otherwise include all remaining mutations (m &gt; 0)\n  filter(case_when(n() == 1 ~ m &gt; 1,\n                       TRUE ~ m &gt; 0)) %&gt;% \n  pivot_longer(cols = c(\"m_count\", \"m_count_expected\")) %&gt;% \n  mutate(label = paste(strainID, \"prey:\", prey_history, \"\\npredator:\", predator_history)) %&gt;% \n  # and make final plot\n  plot_nuc_survival(., 5000, c(1, 10, 100, 1000, 10000), 4)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Distribution of nucleotide multiplicity \\((m_{i})\\) - i.e., the number of replicates with with the same genomic mutation including site and alternative allele - for species \\(\\times\\) treatment combination with sufficient sequencing depth and multiplicities \\(\\gt 1\\). The observed data is shown in blue while the null expectation is shown in red. In all cases the observed \\(m_{i}\\) exceeded the null expectation meaning that we must reject the simple null model of uniform mutation distribution in favor of the alternative model where mutations are nonrandom and cluster across replicate populations.",
    "crumbs": [
      "Metagenome sequencing",
      "2. Parallelism analysis"
    ]
  },
  {
    "objectID": "R/metagenome/02_parallelism.html#conclusion",
    "href": "R/metagenome/02_parallelism.html#conclusion",
    "title": "Metagenome genetic parallelism",
    "section": "3.2 Conclusion",
    "text": "3.2 Conclusion\nNucleotide parallelism results are presented in Figure Figure 1. For these species and evolution treatments this very simple null model mostly predicts that we should expect fewer than two parallel mutations (same position, same alternative allele) across the three replicate populations. For 8 species \\(times\\) treatment combinations the observed data show an excess of nucleotide parallelism relative to this simple null expectation. In particular all species have at least 1 mutation that is identical across all three replicate evolved populations. HAMBI_1287, HAMBI_1972, and HAMBI_2659 did evolve some new parallel nucleotide mutation de novo in the ancestral prey treatment. These will be interesting to follow up on. Still, multi-hit sites constitute only a small fraction of the total observed mutations across all species (~ 14% across species with multi-hit sites). Thus, we will continue our analysis but looking at the gene level.\n\n\nShow/hide code\nnuc_survival %&gt;% \n  mutate(Ntot_f = sum(n)) %&gt;% \n  summarize(perc = sum(n)/Ntot_f*100, .by = \"m\") %&gt;% \n  distinct() %&gt;% \n  mutate(cum_perc = cumsum(perc))",
    "crumbs": [
      "Metagenome sequencing",
      "2. Parallelism analysis"
    ]
  },
  {
    "objectID": "R/metagenome/02_parallelism.html#prepare-input-data-for-non-syn-mutations-only",
    "href": "R/metagenome/02_parallelism.html#prepare-input-data-for-non-syn-mutations-only",
    "title": "Metagenome genetic parallelism",
    "section": "4.1 Prepare input data for non-syn mutations only",
    "text": "4.1 Prepare input data for non-syn mutations only\n\n\nShow/hide code\nmgvars_filt_mb_ns &lt;- mgvars_filt_mb %&gt;% \n  # exclude intragenic, intergenic, and synonymous mutations. Also exclude\n  # fusion functions because these are weird and also rare. Excluding the\n  # modifier category also ensures that we filter out any tRNAs with mutations\n  filter(!str_detect(effect, \"intergenic|intragenic|synonymous|fusion\")) %&gt;% \n  filter(!str_detect(impact, \"MODIFIER\"))",
    "crumbs": [
      "Metagenome sequencing",
      "2. Parallelism analysis"
    ]
  },
  {
    "objectID": "R/metagenome/02_parallelism.html#g-score",
    "href": "R/metagenome/02_parallelism.html#g-score",
    "title": "Metagenome genetic parallelism",
    "section": "4.2 G score",
    "text": "4.2 G score\nWarning! this takes some time\n\n\nShow/hide code\nmuts_by_sp_treat &lt;- mgvars_filt_mb_ns %&gt;% \n  dplyr::select(-c(freq_alt_complete, time_days)) %&gt;%\n  group_by(strainID, prey_history, predator_history) %&gt;% \n  distinct() %&gt;% \n  mutate(groupid = cur_group_id()) %&gt;%\n  group_by(groupid, strainID, prey_history, predator_history)\n\n# doing 10000 permutations\nresult_sp_treat &lt;- run_full_gene_parallelism_pipeline(muts_by_sp_treat, degentab, 10000)\n\n# Save this for later\nwrite_rds(result_sp_treat, here::here(data, \"parallelism_results_sp_treat.rds\"))\n\n\n\n\nShow/hide code\n# Read in previous results\nresult_sp_treat &lt;- read_rds(here::here(data, \"parallelism_results_sp_treat.rds\"))\n\n\n\n4.2.1 Simulating the number of replicates with a parallel gene hit\nAs another sanity check, we took the resamplings from the null distribution and calculated the number of replicates with a parallel gene hit (i.e. the same gene hit in \\(\\geq 2\\) experimental replicates) and compared that to the observed distribution. The null distribution reflected the process of sampling a mutation under a multinomial distribution with probability proportional to the total number of nonsynonymous sites \\(L_{i}\\) in \\(gene_{i}\\). We observed that in 9/16 cases the null distribution produced fewer parallel gene hits than observed in the data from 2 experimental replicates. In all 16 cases the null distribution produced fewer parallel gene hits than observed in the data from 3 experimental replicates. Thus, for some suspicious genes with very high mutational density (see below) we required these genes to be present in all three replicates to include them in our final significant gene lists.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Number of genes (y axis) with nonsynonymous mutation hits in \\(N_{replicates} = \\{n : 1 \\leq n \\leq 3\\}\\) (x axis). Blue bars depict the distribution observed in the data, while red bars depict the null distribution from resampling mutations to the observed \\(n_{tot}\\) set size from each species using the multinomial distribution, where the probability of sampling a non-synonymous mutation at \\(gene_{i}\\) was dependent only on the number of nonsynonymous sites in the gene.\n\n\n\n\n\n4.2.2 Visualize the survival curves for each treatment combination\n\n\nShow/hide code\nsurvcurv &lt;- result_sp_treat$output_df2plot %&gt;% \n  filter(!is.na(xend)) %&gt;% \n  mutate(label = paste(strainID, \"prey:\", prey_history, \"\\npredator:\", predator_history)) %&gt;% \n  ggplot() +\n    geom_segment(\n      aes(\n        x = x,\n        y = y,\n        xend = xend,\n        yend = yend\n      ),\n      linetype = \"dashed\",\n      linewidth = 0.25, color = \"red\"\n    ) +\n    geom_step( aes(x = obs_p, y = value, color = name)) +\n    facet_wrap(~ label, ncol = 4) +\n    labs(x = TeX(\"$-log_{10}P$\"), y = \"Number of genes\") +\n    scale_color_manual(values = c(\"blue\", \"grey50\")) +\n    scale_y_log10(\n      breaks = c(1, 10, 100),\n      labels = scales::trans_format(\"log10\", scales::math_format(10 ^.x))\n    ) +\n    annotation_logticks(sides = \"l\", color = \"grey40\") +\n    coord_cartesian(ylim = c(1, 200)) +\n    theme_bw() +\n    theme(\n      strip.background = element_blank(),\n      panel.grid = element_blank(),\n      legend.position = \"bottom\"\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: The observed \\((N)\\) (blue line) and expected number \\((\\overline{N})\\) (grey line) of genes with \\(P_{i} \\leq P\\), as a function of \\(P\\). The red dashed line denotes the genome-wide significance threshold \\(P^{*}\\) for \\(\\alpha = 0.05\\) defined in Equation Equation 6.\n\n\n\n\n\n4.2.3 Overall G scores\n\n\nShow/hide code\nresult_sp_treat$output_gscore %&gt;% \n  filter(pvalue &lt;= 0.05)\n\n\n\n  \n\n\n\n\n\n4.2.4 Inspecting individual genes\nSome genes tend to have a large number of consecutive mutations which is probably due to incorrect read mapping and not real mutations so we will try and filter these out. We’ll do this by filtering on genes with a mutational density \\(d_{g} \\gt 0.15\\), where the mutational density in gene \\(g\\) was defined as\n\\[d_{g} = \\frac{|A|_{g}}{b_{g} - a_{g}}\\]\nfor all genome positions \\(x\\) on the interval \\(\\{x | a_{g} \\leq x \\leq b_{g}\\}\\) where \\(b_{g}\\) is the greatest position and \\(a_{g}\\) is the smallest position of observed mutations in gene \\(g\\) and \\(|A|_{g}\\) is the cardinality of the mutation set.\n\n\nShow/hide code\nhigh_density_genes &lt;- mgvars_filt_mb_ns %&gt;% \n  group_by(strainID, locus_tag, replicate, prey_history, predator_history) %&gt;% \n  mutate(mutwindox = pos - lag(pos),\n         mut_num = n(),\n         mut_dens = n()/(max(pos) -  min(pos))) %&gt;% \n  ungroup() %&gt;% \n  filter(mut_dens != Inf) %&gt;% \n  filter(mut_dens &gt; 0.15) %&gt;% \n  distinct(locus_tag) %&gt;% \n  pull()\n\n\n\n\nShow/hide code\noutput_gene_table_filt &lt;- result_sp_treat$output_gene_table %&gt;% \n  # only genes exceeding the critical pstar value from the survival curves above\n  filter(neg_log10P &gt;= pstar) %&gt;% \n  # only include genes with at least 3 hits in the same gene or found in more than one replicate.\n  filter(observed_hits_n_i &gt;= 3 | n_replicate &gt; 1) %&gt;%\n  # filters out the problematic genes above unless the number of replicates detected is 2 or more\n  filter(case_when(n_replicate &lt; 2 ~ !(locus_tag %in% high_density_genes), \n                   TRUE ~ n_replicate &gt; 1)) %&gt;% \n  left_join(annotations, by = join_by(locus_tag, strainID))",
    "crumbs": [
      "Metagenome sequencing",
      "2. Parallelism analysis"
    ]
  },
  {
    "objectID": "R/metagenome/02_parallelism.html#jaccard-index-for-convergence-between-treatments",
    "href": "R/metagenome/02_parallelism.html#jaccard-index-for-convergence-between-treatments",
    "title": "Metagenome genetic parallelism",
    "section": "5.1 Jaccard Index for convergence between treatments",
    "text": "5.1 Jaccard Index for convergence between treatments\nWe follow the same approach as in (Shoemaker et al. 2021) where we simulate the process of randomly sampling \\(n = 100,000\\) draws of significant gene set pairs \\((I_{i},I_{j})\\) from every species \\(\\times\\) treatment pair where the probability of sampling a gene is proportional to its length. We then calculate the Jaccard index\n\\[J(I_{i},I_{j}) = \\left|I_{i} \\cap I_{j}\\right|/ \\left|I_{i} \\cup I_{j}\\right|\\] for each null simulation \\(J(I_{i},I_{j})_{null}\\) and calculate an empirical \\(P\\) value for the number of null simulation results exceeding the observed \\(J(I_{i},I_{j})_{observed}\\) to determine whether the intersection of the set of genes was greater (convergence) or less than (divergence) expected by chance.\n\n5.1.1 HAMBI_1287\n\n\nShow/hide code\nH1287_cvdv &lt;- resample_jaccard(100000, \n                               prep4jaccard_resample(output_gene_table_filt, degentab, \n                                                     \"HAMBI_1287\", prey_history, predator_history)\n                               )\n\nwrite_rds(H1287_cvdv, here::here(data, \"jaccard_H1287_cvdv.rds\"))\n\n\n\n\n\n  \n\n\n\n\n\n5.1.2 HAMBI_1972\n\n\nShow/hide code\nH1972_cvdv &lt;- resample_jaccard(100000, \n                               prep4jaccard_resample(output_gene_table_filt, degentab, \n                                                     \"HAMBI_1972\", prey_history, predator_history)\n                               )\n\nwrite_rds(H1972_cvdv, here::here(data, \"jaccard_H1972_cvdv.rds\"))\n\n\n\n\n\n  \n\n\n\n\n\n5.1.3 HAMBI_1977\n\n\nShow/hide code\nH1977_cvdv &lt;- resample_jaccard(100000, \n                               prep4jaccard_resample(output_gene_table_filt, degentab, \n                                                     \"HAMBI_1977\", prey_history, predator_history)\n                               )\n\nwrite_rds(H1977_cvdv, here::here(data, \"jaccard_H1977_cvdv.rds\"))\n\n\n\n\n\n  \n\n\n\n\n\n5.1.4 HAMBI_2659\n\n\nShow/hide code\nH2659_cvdv &lt;- resample_jaccard(100000, \n                               prep4jaccard_resample(output_gene_table_filt, degentab, \n                                                     \"HAMBI_2659\", prey_history, predator_history)\n                               )\n\nwrite_rds(H2659_cvdv, here::here(data, \"jaccard_H2659_cvdv.rds\"))",
    "crumbs": [
      "Metagenome sequencing",
      "2. Parallelism analysis"
    ]
  },
  {
    "objectID": "R/metagenome/02_parallelism.html#enrichment-of-individual-cog-categories",
    "href": "R/metagenome/02_parallelism.html#enrichment-of-individual-cog-categories",
    "title": "Metagenome genetic parallelism",
    "section": "5.2 Enrichment of individual COG categories",
    "text": "5.2 Enrichment of individual COG categories\nSo now we have a list of enriched genes for each species. We can see that, for example, some gene functions pop up multiple times (like transcription factors and sensory kinases). Are these different functions popping up across species more that we would expect by chance? We’ll try and test this using a simulation based approach\n\n\nShow/hide code\n# read back the formatted eggnog data\neggnog &lt;- read_tsv(here::here(shared, \"HAMBI_all_eggnog_formatted.tsv.xz\"))\n\n\n\n\nShow/hide code\ncog_description &lt;- tibble::tribble(\n  ~COG_category_single,                                                  ~COG_category_long,\n            \"J\",               \"J - Translation, ribosomal structure and biogenesis\",\n            \"A\",                               \"A - RNA processing and modification\",\n            \"K\",                                                 \"K – Transcription\",\n            \"L\",                         \"L - Replication, recombination and repair\",\n            \"B\",                              \"B - Chromatin structure and dynamics\",\n            \"D\",    \"D - Cell cycle control, cell division, chromosome partitioning\",\n            \"Y\",                                             \"Y - Nuclear structure\",\n            \"V\",                                            \"V - Defense mechanisms\",\n            \"T\",                                \"T - Signal transduction mechanisms\",\n            \"M\",                        \"M - Cell wall/membrane/envelope biogenesis\",\n            \"N\",                                                 \"N - Cell motility\",\n            \"Z\",                                                  \"Z – Cytoskeleton\",\n            \"W\",                                      \"W - Extracellular structures\",\n            \"U\", \"U - Intracellular trafficking, secretion, and vesicular transport\",\n            \"O\",  \"O - Posttranslational modification, protein turnover, chaperones\",\n            \"X\",                              \"X - Mobilome: prophages, transposons\",\n            \"C\",                              \"C - Energy production and conversion\",\n            \"G\",                         \"G - Carbohydrate transport and metabolism\",\n            \"E\",                           \"E - Amino acid transport and metabolism\",\n            \"F\",                           \"F - Nucleotide transport and metabolism\",\n            \"H\",                             \"H - Coenzyme transport and metabolism\",\n            \"I\",                                \"I - Lipid transport and metabolism\",\n            \"P\",                        \"P - Inorganic ion transport and metabolism\",\n            \"Q\",  \"Q - Secondary metabolites biosynthesis, transport and catabolism\",\n            \"R\",                              \"R - General function prediction only\",\n            \"S\",                                              \"S - Function unknown\"\n  )\n\n\nsave a copy of significantly parallel genes as a table\n\n\nShow/hide code\noutput_gene_table_filt_cog &lt;- left_join(output_gene_table_filt, eggnog) %&gt;% \n  rename(prokka_annotation = product) %&gt;% \n  relocate(strainID, prey_history, predator_history, COG_category_long, Preferred_name, Description, prokka_annotation)\n\n\nJoining with `by = join_by(locus_tag, strainID)`\n\n\nShow/hide code\nwrite_tsv(output_gene_table_filt_cog, here::here(data, \"enriched_parallel_genes.tsv\"))\n\noutput_gene_table_filt_cog\n\n\n\n  \n\n\n\nCalculate the probability of each gene (ns_sites/total_ns_sites) and link to COG categories\n\n\nShow/hide code\neggnog_nslen &lt;- left_join(eggnog, degentab,\n                          by = join_by(strainID, locus_tag)) %&gt;% \n  dplyr::select(strainID, locus_tag, COG_category_single, ns_length) %&gt;% \n  filter(!is.na(COG_category_single)) %&gt;% \n  group_by(strainID) %&gt;% \n  mutate(p = ns_length/sum(ns_length), \n         cog_genes = n()) %&gt;% \n  ungroup()\n\n\n\n5.2.1 Jensen Shannon Divergence\nThis function draws n genes from each species with a probability proportional to gene length, where n = the number of significant parallel genes observed from the data. We repeat this simulation 10 000 times and below we check if 1) the Jensen Shannon divergence between the distribution of the COG categories drawn randomly and the background (i.e., the distribution of COG categories in the whole genome) is greater than the Jensen Shannon divergence between the background and the observed distribution of COG categories in significantly parallel genes. The idea is that if some COG categories are enriched/depleted in the parallel genes, then the JSD divergence between the observed and the background should be larger than the JSD between the random sampled genes (sampling probability based only on gene length) and the background. We calculate an empirical P value by “counting” how many times the simulated JSD exceeds the observed.\n\n\nShow/hide code\ngene_nest &lt;- output_gene_table_filt %&gt;%\n    summarize(nsiggenes = n(), .by = c(strainID, prey_history, predator_history)) %&gt;%\n    left_join(eggnog_nslen,\n              by = join_by(strainID),\n              relationship = \"many-to-many\") %&gt;%\n    nest(data = -c(strainID, prey_history, predator_history))\n\ngene_draw &lt;- function(){\n  gene_nest %&gt;%\n    mutate(locus_tag = map(\n      data,\n      \\(x) sample(\n        x = x$locus_tag,\n        size = unique(x$nsiggenes),\n        prob = x$p,\n        replace = FALSE\n      )\n    )) %&gt;%\n    dplyr::select(-data) %&gt;%\n    unnest(cols = locus_tag) \n}\n\n# take 10 000 random draws of the genes. Use a seed for reproducibility\nwithr::with_seed(12367,\n                 genes_simulated &lt;- map(1:10000, ~gene_draw(), .progress=TRUE) %&gt;% \n                   list_rbind(names_to = \"id\"))\n\n# save the output so we don't need to run again\nwrite_rds(genes_simulated, here::here(data, \"genes_simulated_nomobile.rds\"))\n\n\nSome data formatting\n\n\nShow/hide code\n# read data back\ngenes_simulated &lt;- read_rds(here::here(data, \"genes_simulated_nomobile.rds\"))\n\n# map the locus_tags to COG categories for the simulated\n# gene draws\nCOGs_distribution_simulated &lt;- genes_simulated %&gt;%\n  left_join(eggnog_nslen, by = join_by(strainID, locus_tag)) %&gt;%\n  group_by(id, strainID, prey_history, predator_history) %&gt;% \n  count(COG_category_single, name = \"nsim\") %&gt;% \n  ungroup()\n\n# get the discrete distribution of COGs in the significant parallel genes\nCOGs_distribution_observed &lt;- left_join(output_gene_table_filt, eggnog,\n                                        by = join_by(locus_tag, strainID)) %&gt;% \n  group_by(strainID, prey_history, predator_history) %&gt;% \n  count(COG_category_single, name = \"nobs\") \n\n# get the discrete distribution of COGs across the whole genome of all species\n# this is the null case (i.e. the background that we would expect if there was no\n# enrichment)\nCOGs_distribution_nullexpectation &lt;- eggnog %&gt;% \n  group_by(strainID) %&gt;% \n  count(COG_category_single, name = \"nnull\") \n\n\nNow we calculate the Jensen Shannon divergence between the background and the simulated data to estimate an empirical P value\n\n\nShow/hide code\n# function to calculate the Jensen Shannon divergene of a pair of\n# distributions\nJSD_pair &lt;- function(p, q){\n  m &lt;- 0.5 * (p + q)\n  JS &lt;-  0.5 * (sum(p * log(p/m)) + sum(q * log(q/m)))\n  return(JS)\n}\n\n# Calculate the Jensen Shannon divergence between the COG distribution observed in \n# enriched genes and the COG distribution in the genomic background\nJSD_observed &lt;- left_join(COGs_distribution_observed, COGs_distribution_nullexpectation,\n                          by = join_by(COG_category_single)) %&gt;% \n  group_by(prey_history, predator_history) %&gt;% \n  mutate(p = nobs/sum(nobs), \n         q = nnull/sum(nnull)) %&gt;% \n  summarize(JSD = JSD_pair(p, q))\n\n\nWarning in left_join(COGs_distribution_observed, COGs_distribution_nullexpectation, : Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 1 of `x` matches multiple rows in `y`.\nℹ Row 11 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n`summarise()` has grouped output by 'prey_history'. You can override using the\n`.groups` argument.\n\n\nShow/hide code\n# now calculate JSD between the simulated draws and the backgound distribution\nJSD_simulated &lt;- left_join(COGs_distribution_simulated, \n                           COGs_distribution_nullexpectation,\n                           by = join_by(strainID, COG_category_single)) %&gt;% \n  # drops from calculation categories that aren't in both the observed data\n  # and the resampled data. Need to do this because JSD can't handle zero values\n  drop_na() %&gt;% \n  group_by(id, strainID, prey_history, predator_history) %&gt;% \n  mutate(p = nsim/sum(nsim), \n         q = nnull/sum(nnull)) %&gt;%\n  summarize(JSD = JSD_pair(p, q))\n\n\n`summarise()` has grouped output by 'id', 'strainID', 'prey_history'. You can\noverride using the `.groups` argument.\n\n\nShow/hide code\n# proportion of JSD measures between simulated and the background that are greater\n# than the JSD between the observed and the background\nglobal_p &lt;- left_join(JSD_simulated, JSD_observed, by = join_by(prey_history, predator_history)) %&gt;% \n  mutate(ngt = JSD.x &gt;= JSD.y) %&gt;% \n  group_by(strainID, prey_history, predator_history) %&gt;% \n  summarize(p = sum(ngt)/n())\n\n\n`summarise()` has grouped output by 'strainID', 'prey_history'. You can\noverride using the `.groups` argument.\n\n\nShow/hide code\nglobal_p\n\n\n\n  \n\n\n\nThe overall distribution of COG categories in the parallel genes for each genome in each treatment combination is not significantly different than in the rest of the genome in 9/10 cases. However, for HAMBI_1972 there does seem to be a difference in the distribution of COG categories in enriched genes relative to the genome background.\n\n\n5.2.2 Enrichment of individual COG categories\nOK so the overall distribution of COG categories in the parallel genes is not significantly different than in the rest of the genome - ~40% of the time the JSD between the COG distribution in a random sample and the background is greater than the observed COG distribution and the background.\n\n5.2.2.1 Hypergeometric Test\nWe can test enrichment in individual COG categories in individual species using the hypergeometric test. We will correct for multiple testings by controlling the False Discovery Rate (FDR) using q-values(Storey and Tibshirani 2003) and choosing a maximum FDR threshold of 5%.\n\n\nShow/hide code\nlibrary(qvalue)\n\npar2test &lt;- left_join(output_gene_table_filt, eggnog,\n                      by = join_by(locus_tag, strainID)) %&gt;%\n  filter(!is.na(COG_category)) %&gt;% \n  group_by(strainID, prey_history, predator_history) %&gt;% \n  count(COG_category_single, name = \"n_cog_par\") %&gt;% \n  mutate(n_par = sum(n_cog_par))\n\nback2test &lt;- eggnog %&gt;% \n  filter(!is.na(COG_category)) %&gt;% \n  group_by(strainID) %&gt;% \n  count(COG_category_single, name = \"n_cog_background\") %&gt;% \n  mutate(n_background = sum(n_cog_background))\n\nphypres &lt;- left_join(par2test, back2test, by = join_by(strainID, COG_category_single)) %&gt;% \n  mutate(p_enrich = enricher(n_background, n_par, n_cog_background, n_cog_par, over=TRUE),\n         p_deplete = enricher(n_background, n_par, n_cog_background, n_cog_par, over=FALSE)) %&gt;% \n  mutate(p_enrich_adj = p.adjust(p_enrich, method = \"fdr\"),\n         p_deplete_adj = p.adjust(p_deplete, method = \"fdr\")) \n\nqenrich &lt;- qvalue_truncp(phypres$p_enrich)\nqdeplete &lt;- qvalue_truncp(phypres$p_deplete)\n\nphypres$q_enrich &lt;- qenrich$qvalues\nphypres$q_deplete &lt;- qdeplete$qvalues\n\nphypres %&gt;% \n  relocate(p_enrich, q_enrich, p_enrich_adj) %&gt;% \n  arrange(p_enrich)\n\n\n\n  \n\n\n\n\n\n5.2.2.2 Nonparametric simulation\nWe can also look at different COG categories by simply counting the number of random samplings that have a COG count greater/less than that the observed COG count. Since we resampled the same number of genes as in the observed we can compare the two directly. Below we do this integrated over all species in the community to see if there was any pathway enriched across all species.\n\n\nShow/hide code\nleft_join(COGs_distribution_simulated, COGs_distribution_observed,\n          by = join_by(COG_category_single, strainID, prey_history, predator_history)) %&gt;% \n  drop_na() %&gt;% \n  mutate(gt = if_else(nsim &gt;= nobs, 1, 0)) %&gt;% \n  group_by(COG_category_single, strainID, prey_history, predator_history) %&gt;% \n  summarize(p = sum(gt)/n()) %&gt;% \n  arrange(p) %&gt;% \n  mutate(p_adj = p.adjust(p, method = \"fdr\"))\n\n\n`summarise()` has grouped output by 'COG_category_single', 'strainID',\n'prey_history'. You can override using the `.groups` argument.\n\n\n\n  \n\n\n\n\n\n\n5.2.3 COG Distribution Plot\n\n\nShow/hide code\ncog_pmut &lt;- left_join(output_gene_table_filt, eggnog,\n                      by = join_by(locus_tag, strainID)) %&gt;% \n  count(COG_category_single) %&gt;% \n  mutate(f = n/sum(n),\n         n = n*1000,\n         type = \"parallel_mutations\") \n\ncog_everything &lt;- eggnog %&gt;% \n  count(COG_category_single) %&gt;% \n  mutate(f = n/sum(n), \n         type = \"all_genes\") \n\npcogs &lt;- bind_rows(cog_pmut, cog_everything) %&gt;% \n  drop_na() %&gt;% \n  ggplot() +\n  geom_bar(aes(x = fct_reorder(COG_category_single, f, .desc = F), y=n, fill = type), stat=\"identity\",\n           position = position_dodge( preserve = \"total\")) +\n  scale_fill_brewer(palette = \"Set1\") +\n  labs(x = \"COG Category\", y = \"Fraction genes in COG category\", fill = \"Subset\") +\n  scale_y_continuous(\n    \"N all genes\", \n    sec.axis = sec_axis(~ . * 1/1000, name = \"N parallel genes\")\n  ) +\n  theme_bw() + \n  theme(\n    panel.grid = element_blank(),\n    panel.background = element_blank(),\n    legend.position = \"bottom\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Fraction of genes in each Cluster of Orthologous Groups (COG) category for genes with a COG annotation (red bars, left y-axis) and only genes exhibiting significant genomic parallelism (blue bars, right y-axis) integrated over HAMBI species from metagenomes (i.e., species exceeding the coverage threshold).\n\n\n\n\n\n5.2.4 Species present in the metagenomes\n\n\nShow/hide code\n# species detected in the metagenomes\nmgsp &lt;- c(\"HAMBI_2659\", \"HAMBI_1972\", \"HAMBI_1977\", \"HAMBI_1287\")\n\ncog_pmut_mgsp &lt;- left_join(output_gene_table_filt, eggnog,\n                      by = join_by(locus_tag, strainID)) %&gt;% \n  filter(strainID %in% mgsp) %&gt;% \n  group_by(strainID, prey_history, predator_history) %&gt;% \n  count(COG_category_single, name = \"tot\") %&gt;% \n  # scaling factor to make ploting on 2 axes possible\n  mutate(n = tot*250,\n         f = n/sum(n),\n         type = \"parallel_mutations\") \n\ncog_everything_mgsp &lt;- eggnog %&gt;% \n  filter(strainID %in% mgsp) %&gt;% \n  group_by(strainID) %&gt;% \n  count(COG_category_single) %&gt;% \n  mutate(f = n/sum(n),\n         type = \"all_genes\") %&gt;% \n  expand_grid(prey_history = c(\"anc\", \"evo\"), predator_history = c(\"anc\", \"evo\"))\n\npcogs_mgsp &lt;- semi_join(cog_everything_mgsp, cog_pmut_mgsp,\n          by = join_by(strainID, prey_history, predator_history)) %&gt;% \n  bind_rows(cog_pmut_mgsp) %&gt;% \n  filter(!is.na(COG_category_single)) %&gt;% \n  mutate(treat = paste0(\"prey:\", prey_history, \" | pred:\", predator_history)) %&gt;% \n  ggplot() +\n  geom_bar(aes(x = fct_reorder(COG_category_single, n, .desc = F), y=n, fill = type), stat=\"identity\",\n           position = position_dodge( preserve = \"total\")) +\n  scale_fill_brewer(palette = \"Set1\") +\n  geom_point(data = tibble(x = c(\"U\", \"P\", \"D\", \"D\", \"P\", \"M\"),\n                           y = c(900, 900, 900, 900, 900, 900),\n                           strainID = c(\"HAMBI_2659\", \"HAMBI_2659\", \"HAMBI_1972\", \"HAMBI_1972\", \"HAMBI_2659\" ,\"HAMBI_1972\"),\n                           prey_history = c(\"evo\", \"evo\", \"evo\", \"evo\", \"evo\", \"evo\"),\n                           predator_history = c(\"evo\", \"evo\", \"anc\", \"evo\", \"anc\", \"evo\")),\n             aes(x = x, y = y), shape = 8) +\n  facet_grid(treat ~ strainID) +\n  labs(x = \"COG Category\", y = \"Fraction genes in COG category\", fill = \"Subset\") +\n  scale_y_continuous(\n    \"N all genes\", \n    sec.axis = sec_axis(~ . * 1/250, name = \"N parallel genes\")\n  ) +\n  theme_bw() + \n  theme(\n    panel.grid = element_blank(),\n    strip.background = element_blank(),\n    panel.background = element_blank(),\n    legend.position = \"bottom\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Fraction of genes in each Cluster of Orthologous Groups (COG) category for genes with a COG annotation (red bars, left y-axis) and only genes exhibiting significant genomic parallelism (blue bars, right y-axis) for the four most abundant HAMBI genomes. COG categories for species \\(\\times\\) treatments combinationm are denoted with * if they are significantly enriched in parallel mutations relative to the genomic background. See statistical results in table below.\n\n\n\n\n\nShow/hide code\nggsave(here::here(figs, \"COG_enrich_mgs.svg\"), pcogs_mgsp, width=7, height=7, \n       units=\"in\", device=\"svg\")\n\n\n\n\n\n\n\n\n\n\n\n\nstrainID\nprey history\npredator history\nCOG category\nq value\n\n\n\n\nHAMBI_1972\nEvolved\nAncestral\nD - Cell cycle control, cell division, chromosome partitioning\n0.019\n\n\nHAMBI_1972\nEvolved\nEvolved\nD - Cell cycle control, cell division, chromosome partitioning\n0.026\n\n\nHAMBI_1972\nEvolved\nEvolved\nM - Cell wall/membrane/envelope biogenesis\n0.047\n\n\nHAMBI_2659\nEvolved\nEvolved\nU - Intracellular trafficking, secretion, and vesicular transport\n0.026\n\n\nHAMBI_2659\nEvolved\nAncestral\nP - Inorganic ion transport and metabolism\n0.037\n\n\nHAMBI_2659\nEvolved\nEvolved\nP - Inorganic ion transport and metabolism\n0.037",
    "crumbs": [
      "Metagenome sequencing",
      "2. Parallelism analysis"
    ]
  },
  {
    "objectID": "R/metagenome/04_mutation_dynamics.html",
    "href": "R/metagenome/04_mutation_dynamics.html",
    "title": "Mutational dynamics",
    "section": "",
    "text": "Libraries and global variables\n\n\nShow/hide code\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(patchwork)\nlibrary(ggforce)\nlibrary(latex2exp)\nlibrary(vctrs)\nlibrary(scales)\nlibrary(Polychrome)\n\nsource(here::here(\"R\", \"utils_generic.R\"))\nsource(here::here(\"R\", \"metagenome\", \"utils_parallelism.R\"))\n\n\nSet up some directories\n\n\nShow/hide code\ndata_raw &lt;- here::here(\"_data_raw\", \"metagenome\")\ndata &lt;- here::here(\"data\", \"metagenome\")\nshared &lt;- here::here(\"_data_raw\", \"shared\")\nfigs &lt;- here::here(\"figs\", \"metagenome\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\nfs::dir_create(figs)",
    "crumbs": [
      "Metagenome sequencing",
      "4. Mutational dynamics"
    ]
  },
  {
    "objectID": "R/metagenome/04_mutation_dynamics.html#some-data-formatting",
    "href": "R/metagenome/04_mutation_dynamics.html#some-data-formatting",
    "title": "Mutational dynamics",
    "section": "5.1 Some data formatting",
    "text": "5.1 Some data formatting\n\n\nShow/hide code\n# only denovo (i.e. not observed at time 0)\nmgvars &lt;- mgvars %&gt;% \n  group_by(strainID, chrom, pos, ref, alt, replicate, prey_history, predator_history) %&gt;% \n  mutate(group_id = cur_group_id()) %&gt;% \n  ungroup()\n  \n# only denovo (i.e. not observed at time 0)\nmgvars_denovo &lt;- mgvars %&gt;% \n  group_by(strainID, chrom, pos, ref, alt, replicate, prey_history, predator_history) %&gt;% \n  mutate(group_id = cur_group_id()) %&gt;% \n  mutate(denovo = if_else(freq_alt_complete == 0 & time_days == 0, 1, NA_real_)) %&gt;% \n  fill(denovo, .direction = \"down\") %&gt;% \n  relocate(group_id, freq_alt_complete, denovo) %&gt;% \n  ungroup() %&gt;% \n  filter(!is.na(denovo))\n\n# only nonsynonymous variants\nmgvars_ns &lt;- mgvars %&gt;% \n  filter(!str_detect(effect, \"intergenic|intragenic|synonymous|fusion\")) %&gt;% \n  filter(!str_detect(impact, \"MODIFIER\"))\n\n# only denovo (i.e. not observed at time 0) and nonsynonymous variants\nmgvars_ns_denovo &lt;- mgvars_ns %&gt;% \n  group_by(strainID, chrom, pos, ref, alt, replicate, prey_history, predator_history) %&gt;% \n  mutate(group_id = cur_group_id()) %&gt;% \n  mutate(denovo = if_else(freq_alt_complete == 0 & time_days == 0, 1, NA_real_)) %&gt;% \n  fill(denovo, .direction = \"down\") %&gt;% \n  relocate(group_id, freq_alt_complete, denovo) %&gt;% \n  ungroup() %&gt;% \n  filter(!is.na(denovo)) \n\ncummt &lt;- mgvars %&gt;% \n  summarize(Mt = sum(freq_alt_complete[freq_alt_complete &gt;= 0.15], na.rm = TRUE),\n            .by = c(strainID, time_days, replicate, prey_history, predator_history))\n\ncummt_denovo &lt;- mgvars_denovo %&gt;% \n  summarize(Mt = sum(freq_alt_complete[freq_alt_complete &gt;= 0.15], na.rm = TRUE),\n            .by = c(strainID, time_days, replicate, prey_history, predator_history))\n\ncummt_ns &lt;- mgvars_ns %&gt;% \n  summarize(Mt = sum(freq_alt_complete[freq_alt_complete &gt;= 0.15], na.rm = TRUE),\n            .by = c(strainID, time_days, replicate, prey_history, predator_history))\n\ncummt_ns_denovo &lt;- mgvars_ns_denovo %&gt;% \n  summarize(Mt = sum(freq_alt_complete[freq_alt_complete &gt;= 0.15], na.rm = TRUE),\n            .by = c(strainID, time_days, replicate, prey_history, predator_history))\n\n\n\n\nShow/hide code\nplotmuttraj &lt;- function(df, x, alpha, ylab){\n  ggplot(df, aes(x = time_days, y = {{ x }})) +\n    geom_point(aes(color = strainID, shape = replicate), alpha = alpha) +\n    geom_line(aes(color = strainID, \n                  group = interaction(strainID, prey_history, predator_history, replicate)),\n              alpha = alpha, \n              linetype = \"dashed\") +\n    scale_color_manual(values = hambi_colors) +\n    facet_grid(prey_history ~ predator_history, labeller = label_both) +\n    labs(x = \"Experiment time (days)\", y = ylab, color = NULL, shape = NULL) +\n    scale_x_continuous(breaks = c(0, 8, 28, 60)) +\n    theme_bw() +\n    theme(\n      legend.position = \"bottom\",\n      strip.placement = 'outside',\n      strip.background = element_blank(),\n      panel.grid = element_blank()\n    )\n}",
    "crumbs": [
      "Metagenome sequencing",
      "4. Mutational dynamics"
    ]
  },
  {
    "objectID": "R/metagenome/04_mutation_dynamics.html#sec-allvars",
    "href": "R/metagenome/04_mutation_dynamics.html#sec-allvars",
    "title": "Mutational dynamics",
    "section": "5.2 All variants",
    "text": "5.2 All variants\nThis section considers all variants from the experiment including standing genetic variation present in the evolved populations at T0 and de novo mutations that arise later. It also includes both protein changing and protein non-changing variants.\n\n5.2.1 Cumulative mutation trajectories (M(t))\n\nShow/hide code\ncummt %&gt;% \n  group_by(strainID, time_days, prey_history, predator_history) %&gt;% \n  mutate(mn = mean(Mt)) %&gt;% \n  plotmuttraj(Mt, 0.35, \"M(t)\") +\n  geom_line(aes(y = mn, x= time_days, color = strainID)) +\n  geom_point(aes(y = mn, x= time_days, color = strainID), size = 3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Cumulative mutation (M(t)) trajectories of both amino acid altering and amino acid non-altering variants in HAMBI species genomes with metagenomic coverage \\(\\geq\\) 5X in at least one time point (Figure 1). For evolved prey treatments this includes both standing mutations at T0 and de novo mutations. Transparent points/lines represent individual replicates, while opaque points/lines represent the mean over the three replicates.\n\n\n\n\n\n5.2.2 Total mutation trajectories\n\nShow/hide code\nmgvars %&gt;% \n  summarize(n = sum(freq_alt_complete &gt; 0, na.rm = TRUE),\n            .by = c(strainID, time_days, replicate, prey_history, predator_history)) %&gt;% \n  group_by(strainID, time_days, prey_history, predator_history) %&gt;% \n  mutate(mn = mean(n)) %&gt;% \n  plotmuttraj(n, 0.35, \"Number of mutations\") +\n  geom_line(aes(y = mn, x= time_days, color = strainID)) +\n  geom_point(aes(y = mn, x= time_days, color = strainID), size = 3) +\n  annotation_logticks(sides = \"l\", color = \"grey40\") +\n  scale_y_log10(breaks = c(1, 10, 100),\n                labels = label_log(base = 10, digits = 3)) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Trajectories of the total number of non-zero mutations detected at each time point for both amino acid altering and amino acid non-altering variants in HAMBI genomes with metagenomic coverage \\(\\geq\\) 5X in at least one time point (Figure 1). For evolved prey treatments this includes both standing mutations at T0 and de novo mutations. Transparent points/lines represent individual replicates, while opaque points/lines represent the mean over the three replicates.\n\n\n\n\n\n5.2.3 Fixed mutation trajectories\n\nShow/hide code\nmgvars %&gt;% \n  summarize(n = sum(freq_alt_complete &gt;= 1, na.rm = TRUE),\n            .by = c(strainID, time_days, replicate, prey_history, predator_history)) %&gt;% \n  group_by(strainID, time_days, prey_history, predator_history) %&gt;% \n  mutate(mn = mean(n)) %&gt;% \n  plotmuttraj(n, 0.35, \"Number of fixed mutations\") +\n  geom_line(aes(y = mn, x= time_days, color = strainID)) +\n  geom_point(aes(y = mn, x= time_days, color = strainID), size = 3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Trajectories of the total number of fixed mutations detected at each time point for both amino acid altering and amino acid non-altering variants in HAMBI genomes with metagenomic coverage \\(\\geq\\) 5X in at least one time point (Figure 1). For evolved prey treatments this includes both standing mutations at T0 and de novo mutations. Transparent points/lines represent individual replicates, while opaque points/lines represent the mean over the three replicates.",
    "crumbs": [
      "Metagenome sequencing",
      "4. Mutational dynamics"
    ]
  },
  {
    "objectID": "R/metagenome/04_mutation_dynamics.html#de-novo-variants",
    "href": "R/metagenome/04_mutation_dynamics.html#de-novo-variants",
    "title": "Mutational dynamics",
    "section": "5.3 De novo variants",
    "text": "5.3 De novo variants\nThis section considers only de novo mutations that did not exist within the evolved populations at T0. It includes both protein changing and protein non-changing variants. Thus, the results here for the ancestral bacteria populations here will be the same as in Section 5.2.\n\n5.3.1 Cumulative mutation trajectories (M(t))\n\nShow/hide code\nfig06 &lt;- cummt_denovo %&gt;% \n  group_by(strainID, time_days, prey_history, predator_history) %&gt;% \n  mutate(mn = mean(Mt)) %&gt;% \n  plotmuttraj(Mt, 0.35, \"M(t)\") +\n  geom_line(aes(y = mn, x= time_days, color = strainID)) +\n  geom_point(aes(y = mn, x= time_days, color = strainID), size = 3)\n\nggsave(here::here(figs, \"Mt_denovo.svg\"), fig06, width=7, height=5, units=\"in\",\n       device=\"svg\")\n\nfig06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Cumulative mutation (M(t)) trajectories of de novo amino acid altering and amino acid non-altering variants in HAMBI species genomes with metagenomic coverage \\(\\geq\\) 5X in at least one time point (Figure 1). Transparent points/lines represent individual replicates, while opaque points/lines represent the mean over the three replicates. Plot is analogous to Figure 3 but only includes de novo variants (i.e. excludes standing genetic variation in the evolved populations).\n\n\n\n\n\n5.3.2 Total mutation trajectories\n\nShow/hide code\nmgvars_denovo %&gt;% \n  summarize(n = sum(freq_alt_complete &gt; 0, na.rm = TRUE),\n            .by = c(strainID, time_days, replicate, prey_history, predator_history)) %&gt;% \n  group_by(strainID, time_days, prey_history, predator_history) %&gt;% \n  mutate(mn = mean(n)) %&gt;% \n  plotmuttraj(n, 0.35, \"Number of mutations\") +\n  geom_line(aes(y = mn, x= time_days, color = strainID)) +\n  geom_point(aes(y = mn, x= time_days, color = strainID), size = 3) +\n  annotation_logticks(sides = \"l\", color = \"grey40\") +\n  scale_y_log10(breaks = c(1, 10, 100),\n                labels = label_log(base = 10, digits = 3)) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Trajectories of the total number of non-zero mutations detected at each time point for de novo amino acid altering and amino acid non-altering variants in HAMBI genomes with metagenomic coverage \\(\\geq\\) 5X in at least one time point (Figure 1). For evolved prey treatments this includes both standing mutations at T0 and de novo mutations. Transparent points/lines represent individual replicates, while opaque points/lines represent the mean over the three replicates. Plot is analogous to Figure 4 but only includes de novo variants (i.e. excludes standing genetic variation in the evolved populations).\n\n\n\n\n\n5.3.3 Fixed mutation trajectories\n\nShow/hide code\nmgvars_denovo %&gt;% \n  summarize(n = sum(freq_alt_complete &gt;= 1, na.rm = TRUE),\n            .by = c(strainID, time_days, replicate, prey_history, predator_history)) %&gt;% \n  group_by(strainID, time_days, prey_history, predator_history) %&gt;% \n  mutate(mn = mean(n)) %&gt;% \n  plotmuttraj(n, 0.35, \"Number of fixed mutations\") +\n  geom_line(aes(y = mn, x= time_days, color = strainID)) +\n  geom_point(aes(y = mn, x= time_days, color = strainID), size = 3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Trajectories of the total number of fixed mutations detected at each time point for de novo amino acid altering and amino acid non-altering variants in HAMBI genomes with metagenomic coverage \\(\\geq\\) 5X in at least one time point (Figure 1). Transparent points/lines represent individual replicates, while opaque points/lines represent the mean over the three replicates. Plot is analogous to Figure 5 but only includes de novo variants (i.e. excludes standing genetic variation in the evolved populations).",
    "crumbs": [
      "Metagenome sequencing",
      "4. Mutational dynamics"
    ]
  },
  {
    "objectID": "R/metagenome/04_mutation_dynamics.html#sec-nsvars",
    "href": "R/metagenome/04_mutation_dynamics.html#sec-nsvars",
    "title": "Mutational dynamics",
    "section": "5.4 Non-synonymous variants",
    "text": "5.4 Non-synonymous variants\nThis section considers all nonsynonymous (i.e., amino acid altering) variants from the experiment including standing genetic variation present in the evolved populations at T0 and de novo mutations that arise later.\n\n5.4.1 Cumulative mutation trajectories (M(t))\n\nShow/hide code\ncummt_ns %&gt;% \n  group_by(strainID, time_days, prey_history, predator_history) %&gt;% \n  mutate(mn = mean(Mt)) %&gt;% \n  plotmuttraj(Mt, 0.35, \"M(t) (nonsynonymous)\") +\n  geom_line(aes(y = mn, x= time_days, color = strainID)) +\n  geom_point(aes(y = mn, x= time_days, color = strainID), size = 3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Cumulative mutation (M(t)) trajectories of amino acid altering variants in HAMBI species genomes with metagenomic coverage \\(\\geq\\) 5X in at least one time point (Figure 1). For evolved prey treatments this includes both standing mutations at T0 and de novo mutations. Transparent points/lines represent individual replicates, while opaque points/lines represent the mean over the three replicates. Plot is analogous to Figure 3 but only includes nonsynonymous (amino acid changing) variants.\n\n\n\n\n\n5.4.2 Total mutation trajectories\n\nShow/hide code\nmgvars_ns %&gt;% \n  summarize(n = sum(freq_alt_complete &gt; 0, na.rm = TRUE),\n            .by = c(strainID, time_days, replicate, prey_history, predator_history)) %&gt;% \n  group_by(strainID, time_days, prey_history, predator_history) %&gt;% \n  mutate(mn = mean(n)) %&gt;% \n  plotmuttraj(n, 0.35, \"Number of nonsynonymous mutations\") +\n  geom_line(aes(y = mn, x= time_days, color = strainID)) +\n  geom_point(aes(y = mn, x= time_days, color = strainID), size = 3) +\n  annotation_logticks(sides = \"l\", color = \"grey40\") +\n  scale_y_log10(breaks = c(1, 10, 100),\n                labels = label_log(base = 10, digits = 3)) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Trajectories of the total number of non-zero mutations detected at each time point for amino acid altering variants in HAMBI genomes with metagenomic coverage \\(\\geq\\) 5X in at least one time point (Figure 1). For evolved prey treatments this includes both standing mutations at T0 and de novo mutations. Transparent points/lines represent individual replicates, while opaque points/lines represent the mean over the three replicates. Plot is analogous to Figure 4 but only includes nonsynonymous (amino acid changing) variants.\n\n\n\n\n\n5.4.3 Fixed mutation trajectories\n\nShow/hide code\nmgvars_ns %&gt;% \n  summarize(n = sum(freq_alt_complete &gt;= 1, na.rm = TRUE),\n            .by = c(strainID, time_days, replicate, prey_history, predator_history)) %&gt;% \n  group_by(strainID, time_days, prey_history, predator_history) %&gt;% \n  mutate(mn = mean(n)) %&gt;% \n  plotmuttraj(n, 0.35, \"Number of nonsynonymous fixed mutations\") +\n  geom_line(aes(y = mn, x= time_days, color = strainID)) +\n  geom_point(aes(y = mn, x= time_days, color = strainID), size = 3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Trajectories of the total number of fixed mutations detected at each time point for amino acid altering variants in HAMBI genomes with metagenomic coverage \\(\\geq\\) 5X in at least one time point (Figure 1). For evolved prey treatments this includes both standing mutations at T0 and de novo mutations. Transparent points/lines represent individual replicates, while opaque points/lines represent the mean over the three replicates. Plot is analogous to Figure 5 but only includes non-synonymous (amino acid changing) variants.",
    "crumbs": [
      "Metagenome sequencing",
      "4. Mutational dynamics"
    ]
  },
  {
    "objectID": "R/metagenome/04_mutation_dynamics.html#de-novo-non-synonymous-variants",
    "href": "R/metagenome/04_mutation_dynamics.html#de-novo-non-synonymous-variants",
    "title": "Mutational dynamics",
    "section": "5.5 De novo, non-synonymous variants",
    "text": "5.5 De novo, non-synonymous variants\nThis section considers only de novo mutations that did not exist within the evolved populations at T0 for only non-synonymous (i.e., amino acid altering) variants. Thus, the results here for the ancestral bacteria populations will be the same as in Section 5.4\n\n5.5.1 Cumulative mutation trajectories (M(t))\n\nShow/hide code\ncummt_ns_denovo %&gt;% \n  group_by(strainID, time_days, prey_history, predator_history) %&gt;% \n  mutate(mn = mean(Mt)) %&gt;% \n  plotmuttraj(Mt, 0.35, \"M(t) (de novo, nonsynonymous)\") +\n  geom_line(aes(y = mn, x= time_days, color = strainID)) +\n  geom_point(aes(y = mn, x= time_days, color = strainID), size = 3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Cumulative mutation (M(t)) trajectories of de novo amino acid altering variants in HAMBI species genomes with metagenomic coverage \\(\\geq\\) 5X in at least one time point (Figure 1). Transparent points/lines represent individual replicates, while opaque points/lines represent the mean over the three replicates. Plot is analogous to Figure 3 but only includes de novo (i.e., not present at T0) and non-synonymous (amino acid changing) variants.\n\n\n\n\n\n5.5.2 Total mutation trajectories\n\nShow/hide code\nfig13 &lt;- mgvars_ns_denovo %&gt;% \n  summarize(n = sum(freq_alt_complete &gt; 0, na.rm = TRUE),\n            .by = c(strainID, time_days, replicate, prey_history, predator_history)) %&gt;% \n  group_by(strainID, time_days, prey_history, predator_history) %&gt;% \n  mutate(mn = mean(n)) %&gt;% \n  plotmuttraj(n, 0.35, \"Number of de novo nonsynonymous mutations\") +\n  geom_line(aes(y = mn, x= time_days, color = strainID)) +\n  geom_point(aes(y = mn, x= time_days, color = strainID), size = 3) +\n  annotation_logticks(sides = \"l\", color = \"grey40\") +\n  scale_y_log10(breaks = c(1, 10, 100),\n                labels = label_log(base = 10, digits = 3))\n\nggsave(here::here(figs, \"cummuts_denovo_nonsyn.svg\"), fig13, width=7, height=5, units=\"in\",\n       device=\"svg\")\n\nfig13\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: Trajectories of the total number of non-zero mutations detected at each time point for de novo amino acid altering variants in HAMBI genomes with metagenomic coverage \\(\\geq\\) 5X in at least one time point (Figure 1). Transparent points/lines represent individual replicates, while opaque points/lines represent the mean over the three replicates. Plot is analogous to Figure 4 but only includes de novo (i.e., not present at T0) and non-synonymous (amino acid changing) variants.\n\n\n\n\n\n5.5.3 Fixed mutation trajectories\n\nShow/hide code\nmgvars_ns_denovo %&gt;% \n  summarize(n = sum(freq_alt_complete &gt;= 1, na.rm = TRUE),\n            .by = c(strainID, time_days, replicate, prey_history, predator_history)) %&gt;% \n  group_by(strainID, time_days, prey_history, predator_history) %&gt;% \n  mutate(mn = mean(n)) %&gt;% \n  plotmuttraj(n, 0.35, \"Number of de novo, nonsynonymous fixed mutations\") +\n  geom_line(aes(y = mn, x= time_days, color = strainID)) +\n  geom_point(aes(y = mn, x= time_days, color = strainID), size = 3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Trajectories of the total number of fixed mutations detected at each time point for de novo amino acid altering variants in HAMBI genomes with metagenomic coverage \\(\\geq\\) 5X in at least one time point (Figure 1). Transparent points/lines represent individual replicates, while opaque points/lines represent the mean over the three replicates. Plot is analogous to Figure 5 but only includes de novo (i.e., not present at T0) and non-synonymous (amino acid changing) variants.",
    "crumbs": [
      "Metagenome sequencing",
      "4. Mutational dynamics"
    ]
  },
  {
    "objectID": "R/metagenome/04_mutation_dynamics.html#de-novo-variants-both-amino-acid-chaning-and-non-changing",
    "href": "R/metagenome/04_mutation_dynamics.html#de-novo-variants-both-amino-acid-chaning-and-non-changing",
    "title": "Mutational dynamics",
    "section": "6.1 De novo variants (both amino acid chaning and non-changing)",
    "text": "6.1 De novo variants (both amino acid chaning and non-changing)\n\nShow/hide code\nmgvars_denovo %&gt;% \n  group_by(group_id) %&gt;% \n  filter(!is.na(freq_alt_complete) & freq_alt_complete != 0) %&gt;% \n  filter(freq_alt_complete &gt;= 0.50) %&gt;% \n  slice_min(time_days) %&gt;% \n  slice(1) %&gt;% \n  ggplot(aes(x = factor(time_days))) +\n  geom_bar(aes(fill = strainID)) +\n  scale_fill_manual(values = hambi_colors) +\n  facet_grid(prey_history ~ predator_history, labeller = label_both) +\n  labs(x = TeX(\"Time to major allele ( $f_{max} \\\\geq 0.5$ )\"), y = TeX(\" $n_{allele}$ with $f_{max} \\\\geq 0.5$ \"), fill = NULL, shape = NULL) +\n  theme_bw() +\n  theme(\n    legend.position = \"bottom\",\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n    panel.grid = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 15: Count of alternative alleles with \\(f_{max} \\geq 0.5\\) plotted against the time (days) when the alternative allele first reaches major allele status \\((f_{max} \\geq 0.5)\\). Colors represent the proportion of alleles from different HAMBI species. Plot includes both amino acid changing and non-changing de novo mutations (i.e. excludes standing genetic variation from T0 in the evolved bacterial populations).",
    "crumbs": [
      "Metagenome sequencing",
      "4. Mutational dynamics"
    ]
  },
  {
    "objectID": "R/metagenome/04_mutation_dynamics.html#de-novo-variants-non-synonymous",
    "href": "R/metagenome/04_mutation_dynamics.html#de-novo-variants-non-synonymous",
    "title": "Mutational dynamics",
    "section": "6.2 De novo variants, non-synonymous",
    "text": "6.2 De novo variants, non-synonymous\n\nShow/hide code\nmgvars_ns_denovo %&gt;% \n  group_by(group_id) %&gt;% \n  filter(!is.na(freq_alt_complete) & freq_alt_complete != 0) %&gt;% \n  filter(freq_alt_complete &gt;= 0.50) %&gt;% \n  slice_min(time_days) %&gt;% \n  slice(1) %&gt;% \n  ggplot(aes(x = factor(time_days))) +\n  geom_bar(aes(fill = strainID)) +\n  scale_fill_manual(values = hambi_colors) +\n  facet_grid(prey_history ~ predator_history, labeller = label_both) +\n  labs(x = TeX(\"Time to major allele ( $f_{max} \\\\geq 0.5$ )\"), y = TeX(\" $n_{allele}$ with $f_{max} \\\\geq 0.5$ \"), fill = NULL, shape = NULL) +\n  theme_bw() +\n  theme(\n    legend.position = \"bottom\",\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n    panel.grid = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Count of alternative alleles with \\(f_{max} \\geq 0.5\\) plotted against the time (days) when the alternative allele first reaches major allele status \\((f_{max} \\geq 0.5)\\). Colors represent the proportion of alleles from different HAMBI species. Plot includes only amino acid changing de novo variants (i.e. excludes standing genetic variation from T0 in the evolved bacterial populations).\n\n\n\nThis plot suggests that most de novo alternative alleles (either amino acid changing or non chaning) become the major allele by either day 28 or 60 for the ancestral bacteria populations. For the evolved populations this evolution seems to happen faster where some alt alleles become the major allele already by day 28 but this is only for HAMBI_2659.",
    "crumbs": [
      "Metagenome sequencing",
      "4. Mutational dynamics"
    ]
  },
  {
    "objectID": "R/metagenome/04_mutation_dynamics.html#delta-l",
    "href": "R/metagenome/04_mutation_dynamics.html#delta-l",
    "title": "Mutational dynamics",
    "section": "8.1 \\(\\Delta l\\)",
    "text": "8.1 \\(\\Delta l\\)\nThis is the same formatting that is done in the prior parallelism analysis.\n\n\nShow/hide code\ntofilter &lt;- mgvars %&gt;% \n  filter(time_days == 0) %&gt;% \n  filter(freq_alt_complete == 1) %&gt;% \n  dplyr::select(chrom, pos, ref, alt) %&gt;% \n  distinct()\n\nmgvars_filt_mb_ns &lt;- anti_join(mgvars, tofilter, by = join_by(chrom, pos, ref, alt)) %&gt;% \n  # exclude variants that were added to make complete time course\n  filter(!is.na(freq_alt_complete)) %&gt;% \n  filter(freq_alt_complete &gt; 0) %&gt;% \n  filter(time_days != 0) %&gt;% \n  filter(!str_detect(effect, \"intergenic|intragenic|synonymous|fusion\")) %&gt;% \n  filter(!str_detect(impact, \"MODIFIER\")) %&gt;% \n  # double check to remove any noncoding mutations\n  filter(locus_tag %in% pull(filter(degentab, !is.na(ns_length)), locus_tag))\n\n\nWe now want to look at the extent of multiplicity at different binned \\(f_{max}\\)\n\n\nShow/hide code\nmultiplicity_binned &lt;- mgvars_filt_mb_ns %&gt;%\n  # automatically bin f_max into 5 categories\n  mutate(fbin = cut_interval(freq_alt_complete, 5)) %&gt;% \n  summarize(n_i = n(), \n            n_replicate = n_distinct(replicate),\n    .by = c(\"locus_tag\", \"strainID\", \"fbin\", \"prey_history\", \"predator_history\")) %&gt;% \n  group_by(locus_tag, strainID) %&gt;% \n  complete(fbin, prey_history, predator_history,\n           fill = list(n_i = 0, n_replicate = 0)) %&gt;% \n  ungroup() %&gt;% \n  group_by(strainID, fbin, prey_history, predator_history) %&gt;% \n  mutate(Ntot = sum(n_i)) %&gt;% \n  ungroup()\n\n\nMake df with information about gene lengths\n\n\nShow/hide code\ngene_tab &lt;- degentab %&gt;% \n  dplyr::select(strainID, locus_tag, l_i = ns_length) %&gt;% \n  drop_na() %&gt;% \n  group_by(strainID) %&gt;% \n  mutate(\n    # compute the number of genes in the genome\n    n_genes = n(),\n    # compute the sum of non-syn sites in genome\n    Ltot = sum(l_i),\n    # compute the average non-syn sites per gene\n    Lavg = mean(l_i)) %&gt;% \n  ungroup() %&gt;% \n  filter(strainID %in% c(\"HAMBI_0403\", \"HAMBI_1287\", \"HAMBI_1972\", \"HAMBI_1977\", \"HAMBI_2659\")) %&gt;% \n  # expanding this now to make later joining faster\n  expand_grid(prey_history = c(\"anc\", \"evo\"), \n              predator_history = c(\"anc\", \"evo\"),\n              fbin = unique(multiplicity_binned$fbin))\n\n\nThis prepares the tibble that we can use in the next step to calculate the G scores and \\(\\Delta L\\)\n\n\nShow/hide code\ng_prepped &lt;- left_join(gene_tab, multiplicity_binned) %&gt;% \n  arrange(strainID, prey_history, predator_history, fbin, locus_tag) %&gt;% \n  replace_na(list(n_i = 0, n_replicate = 0)) %&gt;% \n  group_by(strainID, prey_history, predator_history, fbin) %&gt;% \n  fill(Ntot, .direction = \"updown\") %&gt;% \n  ungroup() %&gt;% \n  group_by(strainID, prey_history, predator_history) %&gt;% \n  filter(sum(Ntot, na.rm = TRUE) != 0) %&gt;% \n  ungroup()\n\n\nJoining with `by = join_by(strainID, locus_tag, prey_history, predator_history,\nfbin)`\n\n\nThis function calculate \\(\\Delta L\\) but from a bootstrapping of the source dataframes to get sample means plus confidence intervals. We use rsample package hence the use of analysis(df). See the next section for implementation\n\n\nShow/hide code\nG_score_boot &lt;- function(df, boot=TRUE){\n  \n  if (boot) {\n    # convert the rsample splits to tibble\n    df &lt;- rsample::analysis(df)\n  }\n  # compute the expected multiplicity value\n  m_exp &lt;- unique(df$Ntot) / unique(df$n_genes)\n  # compute gene multiplicity for gene i\n  m_i &lt;-  df$n_i * unique(df$Lavg) / df$l_i\n  # compute the G score for each gene\n  g_score &lt;- df$n_i * log(m_i / m_exp)\n  # net increase in log-likelihood compared to the null model of m_i / m_exp =1\n  # normalized to the total mutations\n  sum(g_score, na.rm=T) / unique(df$Ntot)\n}\n\n\nWe need the package rsample to do the boostrap analysis and we need Hmisc to get the bootstrapped confidence intervals\n\n\nShow/hide code\nlibrary(rsample)\nlibrary(Hmisc)\n\n# this is a bit slow so saving the results\ng_boot &lt;- g_prepped %&gt;% \n  tidyr::nest(.by = c(strainID, prey_history, predator_history, fbin)) %&gt;% \n  dplyr::mutate(boots = purrr::map(data, function(df) rsample::bootstraps(df, times = 1000))) %&gt;% \n  dplyr::mutate(g_scores = purrr::map(boots, \\(boot) purrr::map_dbl(boot$splits, G_score_boot))) %&gt;% \n  dplyr::summarize(meanboot = purrr::map(g_scores, ggplot2::mean_cl_boot),\n            .by = c(strainID, prey_history, predator_history, fbin)) %&gt;% \n  tidyr::unnest(cols = c(meanboot))\n\n# Save this for later\nwrite_rds(g_boot, here::here(data, \"g_score_bootstap.rds\"))\n\n\nRead in saved bootstrapped data\n\n\nShow/hide code\n# Read in previous results\ng_boot &lt;- read_rds(here::here(data, \"g_score_bootstap.rds\"))\n\n\nPlot bootstrapped \\(\\Delta l\\) range with \\(\\Delta l\\) from full dataset at different values of \\(f_{max}\\)\n\nShow/hide code\npg_boot &lt;- ggplot(g_boot, aes(x = fbin, y = y, ymin = ymin, ymax = ymax)) +\n  geom_pointrange(aes(color = strainID), \n                  position = position_dodge(width = 0.5)) +\n  facet_grid(prey_history ~ predator_history, labeller = label_both) +\n  labs(x = TeX(\"Binned maximum observed allele frequency ($f_{max}$) \"), y = TeX(\"Extent of parallel evolution ($\\\\Delta l$)\"), color = NULL, shape = NULL) +\n  scale_color_manual(values = hambi_colors) + \n  scale_x_discrete(guide = guide_axis(angle = 45)) +\n  theme_bw() +\n  theme(\n    legend.position = \"bottom\",\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n    panel.grid = element_blank())\n\npg_boot\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 18",
    "crumbs": [
      "Metagenome sequencing",
      "4. Mutational dynamics"
    ]
  },
  {
    "objectID": "R/metagenome/04_mutation_dynamics.html#g-score",
    "href": "R/metagenome/04_mutation_dynamics.html#g-score",
    "title": "Mutational dynamics",
    "section": "8.2 G score",
    "text": "8.2 G score\nAlso calculate the G score from (Tenaillon et al. 2016) and look at the relationship with \\(f_{max}\\). The difference between the analysis above is that G-score is the non-summed and non-normalized form of \\(\\Delta l\\) and it is calculated for every gene uniquely instead of at different \\(f_{max}\\) bins. Briefly,\n\\[\nG_{i} = n_{i} \\log \\left ( \\frac{m_{i}}{\\overline{m}} \\right )\n\\] where the expected multiplicity \\(\\overline{m}\\) is\n\\[\n\\overline{m} = n_{tot}/n_{genes}\n\\]\nand the observed multiplicity is\n\\[\nm_{i} = n_{i} \\cdot \\frac{\\overline{L}}{L_{i}}\n\\]\n\n\nShow/hide code\nmultiplicity &lt;- mgvars_filt_mb_ns %&gt;%\n  dplyr::summarize(n_i = n(),\n            n_replicate = n_distinct(replicate), \n            .by = c(\"locus_tag\", \"strainID\", \"prey_history\", \"predator_history\")) %&gt;%\n  dplyr::group_by(strainID, prey_history, predator_history) %&gt;%\n  dplyr::mutate(Ntot = sum(n_i)) %&gt;%\n  dplyr::ungroup()\n\ng_prepped_nobin &lt;- left_join(dplyr::distinct(dplyr::select(gene_tab, -fbin)), multiplicity) %&gt;% \n  arrange(strainID, prey_history, predator_history, locus_tag) %&gt;% \n  replace_na(list(n_i = 0, n_replicate = 0)) %&gt;% \n  group_by(strainID, prey_history, predator_history) %&gt;% \n  fill(Ntot, .direction = \"updown\") %&gt;% \n  ungroup() %&gt;% \n  group_by(strainID, prey_history, predator_history) %&gt;% \n  filter(sum(Ntot, na.rm = TRUE) != 0) %&gt;% \n  ungroup()\n\n\nJoining with `by = join_by(strainID, locus_tag, prey_history,\npredator_history)`\n\n\nShow/hide code\nG_score_tidy &lt;- function(df){\n  df %&gt;% \n  # compute the expected multiplicity value\n  mutate(m_exp = Ntot / n_genes) %&gt;% \n  # compute gene multiplicity for gene i\n  mutate(m_i =  n_i * Lavg / l_i) %&gt;% \n  # compute the G score for each gene\n  mutate(g_score = n_i * log(m_i / m_exp)) %&gt;% \n  # net increase in log-likelihood compared to the null model of m_i / m_exp =1\n  # normalized to the total mutations\n  mutate(delta_l = sum(g_score, na.rm=T) / Ntot)\n}\n\ng_scores &lt;- g_prepped_nobin %&gt;% \n  group_by(strainID, prey_history, predator_history) %&gt;% \n  G_score_tidy() %&gt;% \n  drop_na() %&gt;% \n  ungroup()\n\ng_scores_fmax &lt;- left_join(g_scores, mgvars,\n          by = join_by(strainID, locus_tag, prey_history, predator_history)) %&gt;% \n  group_by(locus_tag) %&gt;% \n  filter(freq_alt_complete == max(freq_alt_complete, na.rm = TRUE)) %&gt;% \n  ungroup()\n\n\n\nShow/hide code\nfig19 &lt;- ggplot(g_scores_fmax, aes(x = freq_alt_complete, y = g_score)) +\n  geom_smooth(method = \"lm\", formula = 'y ~ x') +\n  geom_point(aes(color = strainID)) +\n  scale_color_manual(values = hambi_colors) + \n  facet_grid(prey_history ~ predator_history, labeller = label_both) +\n  labs(x = TeX(\"Maximum observed allele frequency ($f_{max}$) \"), y = TeX(\"Extent of parallel evolution (Gene-wise $G_{i}$)\"), color = NULL, shape = NULL) +\n  annotation_logticks(sides = \"bl\", color = \"grey40\") +\n  scale_x_log10() +\n  scale_y_log10() +\n  theme_bw() +\n  theme(\n    legend.position = \"bottom\",\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n    panel.grid = element_blank())\n\nggsave(here::here(figs, \"G_score_fmax.svg\"), fig19, width=7, height=6, units=\"in\",\n       device=\"svg\")\n\nfig19\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 19\n\n\n\nLinear regression for different treatment combinations (over species). Overall, we find a clear positive relationship between the gene-wise extent of parallel evolution (G score) and the maximum observed allele frequency for that gene in 3/4 treatment combinations. We also find a positive relationship for the prey: evo | predator: anc treatment combination but the significance of this relationship is unclear (P value = 0.07).\n\n\nShow/hide code\ng_scores_fmax %&gt;% \n  tidyr::nest(data = -c(prey_history, predator_history)) %&gt;% \n  dplyr::mutate(model = map(data, \\(df) lm(g_score ~ freq_alt_complete, na.rm = TRUE, data = df))) %&gt;% \n  dplyr::mutate(tidy = map(model, broom::tidy)) %&gt;% \n  unnest(tidy) %&gt;% \n  dplyr::select(-data, -model) %&gt;% \n  dplyr::filter(term != \"(Intercept)\") %&gt;% \n  arrange(p.value)\n\n\nWarning: There were 4 warnings in `dplyr::mutate()`.\nThe first warning was:\nℹ In argument: `model = map(...)`.\nCaused by warning:\n! In lm.fit(x, y, offset = offset, singular.ok = singular.ok, ...) :\n extra argument 'na.rm' will be disregarded\nℹ Run `dplyr::last_dplyr_warnings()` to see the 3 remaining warnings.\n\n\n\n  \n\n\n\nLinear regression for all different species in different treatment combinations. By including every species we lose statistical power because some species have relatively few observations. However, for all 4 species in the prey: evo | predator: anc treatment combination we find a clear positive relationship between the gene-wise extent of parallel evolution (G score) and the maximum observed allele frequency for that gene. We also find this positive relationmship for HAMBI_2659 in the prey: evo | predator: evo treatment combination.\n\n\nShow/hide code\ng_scores_fmax %&gt;% \n  tidyr::nest(data = -c(strainID, prey_history, predator_history)) %&gt;% \n  dplyr::mutate(model = map(data, \\(df) lm(g_score ~ freq_alt_complete, na.rm = TRUE, data = df))) %&gt;% \n  dplyr::mutate(tidy = map(model, broom::tidy)) %&gt;% \n  unnest(tidy) %&gt;% \n  dplyr::select(-data, -model) %&gt;% \n  dplyr::filter(term != \"(Intercept)\") %&gt;% \n  arrange(p.value)\n\n\nWarning: There were 15 warnings in `dplyr::mutate()`.\nThe first warning was:\nℹ In argument: `model = map(...)`.\nCaused by warning:\n! In lm.fit(x, y, offset = offset, singular.ok = singular.ok, ...) :\n extra argument 'na.rm' will be disregarded\nℹ Run `dplyr::last_dplyr_warnings()` to see the 14 remaining warnings.",
    "crumbs": [
      "Metagenome sequencing",
      "4. Mutational dynamics"
    ]
  },
  {
    "objectID": "R/metagenome/03_analyze_metagenome_variant_timeseries.html",
    "href": "R/metagenome/03_analyze_metagenome_variant_timeseries.html",
    "title": "Plot variant time series",
    "section": "",
    "text": "Libraries and global variables\n\n\nShow/hide code\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(fishualize)\nlibrary(withr)\nlibrary(scales)\nlibrary(patchwork)\nlibrary(Polychrome)\n\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\nSet up some directories\n\n\nShow/hide code\ndata_raw &lt;- here::here(\"_data_raw\", \"metagenome\")\ndata &lt;- here::here(\"data\", \"metagenome\")\nshared &lt;- here::here(\"_data_raw\", \"shared\")\nfigs &lt;- here::here(\"figs\", \"metagenome\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\nfs::dir_create(figs)",
    "crumbs": [
      "Metagenome sequencing",
      "3. Variant plotting"
    ]
  },
  {
    "objectID": "R/metagenome/03_analyze_metagenome_variant_timeseries.html#heatmap-all-species-together",
    "href": "R/metagenome/03_analyze_metagenome_variant_timeseries.html#heatmap-all-species-together",
    "title": "Plot variant time series",
    "section": "4.1 Heatmap all species together",
    "text": "4.1 Heatmap all species together\n\n\nShow/hide code\nblank_theme01 &lt;- function(){\n  theme(\n    panel.grid = element_blank(),\n    panel.border = element_blank(),\n    panel.background = element_blank(),\n    axis.text = element_blank(),\n    axis.ticks = element_blank(),\n    legend.title = element_blank(),\n    plot.margin = unit(c(0,0,0,0), \"cm\"),\n    strip.background = element_blank(),\n    strip.text = element_blank()\n  )\n}\n\nblank_theme02 &lt;- function(){\n  theme(\n    panel.grid = element_blank(),\n    panel.border = element_blank(),\n    panel.background = element_blank(),\n    axis.ticks = element_blank(),\n    legend.title = element_blank(),\n    strip.background = element_blank(),\n    strip.text = element_blank()\n  )\n}\n\nphoriz_bar &lt;- function(df, fillvar, mypal){\n  # only take the first time point so to make one bar\n  filter(df, day == 0) %&gt;% \n    ggplot(aes(y = day,  x=mylab2, fill = {{ fillvar }})) +\n    geom_tile() +\n    labs(x = NULL, y = NULL) +\n    facet_wrap(prey_history ~ predator_history, scales = \"free\", nrow = 1) +\n    scale_fill_manual(values = {{ mypal }}) + \n    blank_theme01()\n}\n\npheat_nolb &lt;- function(df, fillvar){\n  ggplot(df, aes(y = day,  x=mylab2, fill = {{ fillvar }} )) +\n    geom_tile() +\n    labs(x = NULL, y = NULL) +\n    facet_wrap(prey_history ~ predator_history, scales = \"free\", nrow = 1) +\n    scale_fill_viridis_c(limits = c(0, 1), trans = \"sqrt\") +\n    scale_x_discrete(guide = guide_axis(angle = 90)) +\n    blank_theme01()\n}\n\npheat_labs &lt;- function(df, fillvar){\n  ggplot(df, aes(y = day,  x=mylab2, fill = {{ fillvar }})) +\n    geom_tile() +\n    labs(x = NULL, y = NULL) +\n    facet_wrap(prey_history ~ predator_history, scales = \"free\", nrow = 1) +\n    scale_fill_viridis_c(limits = c(0, 1), trans = \"sqrt\") +\n    scale_x_discrete(guide = guide_axis(angle = 90)) +\n    blank_theme02()\n}\n\n\n\n4.1.1 All alleles\n\n\nShow/hide code\n#clupal &lt;- unname(createPalette(length(unique(myclust)), c(\"#F3874AFF\", \"#FCD125FF\"), M=5000))\nclupal &lt;- gray.colors(length(unique(myclust)), start = 0.1, end = 0.9, gamma = 2.2, 1, rev = TRUE)\nnames(clupal) &lt;- unique(myclust)\n\npheat_all &lt;- phoriz_bar(filter(df2plot, strainID == \"HAMBI_2659\"), cluster, clupal) +\n  pheat_nolb(filter(df2plot, strainID == \"HAMBI_2659\"), freq_alt_complete) +\n  phoriz_bar(filter(df2plot, strainID == \"HAMBI_1972\"), cluster, clupal) + \n  pheat_nolb(filter(df2plot, strainID == \"HAMBI_1972\"), freq_alt_complete) + \n  phoriz_bar(filter(df2plot, strainID == \"HAMBI_1977\"), cluster, clupal) + \n  pheat_nolb(filter(df2plot, strainID == \"HAMBI_1977\"), freq_alt_complete) + \n  phoriz_bar(filter(df2plot, strainID == \"HAMBI_1287\"), cluster, clupal) + \n  pheat_nolb(filter(df2plot, strainID == \"HAMBI_1287\"), freq_alt_complete) + \n  phoriz_bar(filter(df2plot, strainID == \"HAMBI_0403\"), cluster, clupal) + \n  pheat_nolb(filter(df2plot, strainID == \"HAMBI_0403\"), freq_alt_complete) + \n  plot_layout(ncol = 1, nrow = 10,\n              heights = c(0.25, 1, 0.25, 1, 0.25, 1, 0.25, 1, 0.25, 1),\n              guides = \"collect\")\n\npheat_all\n\n\n\n\n\n\n\n\n\n\n4.1.1.1 Save\n\n\nShow/hide code\nggsave(here::here(figs, \"heatmap_all_alleles.svg\"), pheat_all, width=11, height=4, units=\"in\",\n       device=\"svg\")\n\n\n\n\n\n4.1.2 Parallel genes\n\n\nShow/hide code\npdfr_evo &lt;- left_join(par_genes, df2plot, \n          by = join_by(locus_tag, strainID, prey_history, predator_history, chrom)) %&gt;% \n  filter(prey_history == \"evo\") %&gt;% \n  # some manual renaming\n  mutate(gene = case_when(locus_tag == \"H1287_02172\" ~ \"yddV_2\",\n                          locus_tag == \"H1977_02612\" ~ \"dppA/oppA\",\n                          locus_tag == \"H1972_00299\" ~ \"PAP2_like\",\n                          locus_tag == \"H1972_02826\" ~ \"ynjC\",\n                          locus_tag == \"H1972_00671\" ~ \"yqaA\",\n                          locus_tag == \"H1972_00421\" ~ \"hyp\",\n                          locus_tag == \"H1972_02723\" ~ \"yifE\",\n                          locus_tag == \"H2659_01789\" ~ \"hyp\",\n                          TRUE ~ gene)) %&gt;% \n  mutate(gene_lab = if_else(is.na(gene), Preferred_name, gene)) %&gt;% \n  mutate(gene_lab = if_else(gene_lab == \"-\", locus_tag, gene_lab)) %&gt;% \n  mutate(gene_lab = paste0(gene_lab, \" | \", replicate, \" | \",  cluster, \"|\", group_id)) %&gt;% \n  arrange(COG_category_long, gene_lab) %&gt;% \n  mutate(mylab2 = factor(gene_lab, unique(gene_lab)))\n\npdfr_anc &lt;- left_join(par_genes, df2plot, \n          by = join_by(locus_tag, strainID, prey_history, predator_history, chrom)) %&gt;% \n  filter(prey_history == \"anc\") %&gt;%\n  mutate(gene = case_when(locus_tag == \"H1972_02826\" ~ \"ynjC\",\n                          locus_tag == \"H1972_00421\" ~ \"hyp\",\n                          TRUE ~ gene)) %&gt;% \n  mutate(gene_lab = if_else(is.na(gene), Preferred_name, gene)) %&gt;% \n  mutate(gene_lab = if_else(gene_lab == \"-\", locus_tag, gene_lab)) %&gt;% \n  mutate(gene_lab = paste0(gene_lab, \" | \", replicate, \" | \",  cluster, \"|\", group_id)) %&gt;% \n  arrange(COG_category_long, gene_lab) %&gt;% \n  mutate(mylab2 = factor(gene_lab, unique(gene_lab)))\n  \n# evolved\npheat_par &lt;- phoriz_bar(filter(pdfr_evo, strainID == \"HAMBI_2659\"), COG_category_long, cogpal) +\n  pheat_labs(filter(pdfr_evo, strainID == \"HAMBI_2659\"), freq_alt_complete) + \n  # evolved 1972\n  phoriz_bar(filter(pdfr_evo, strainID == \"HAMBI_1972\"), COG_category_long, cogpal) +\n  pheat_labs(filter(pdfr_evo, strainID == \"HAMBI_1972\"), freq_alt_complete) + \n  # ancestral 1972 - the only species that has significantly parallel genes in the ancestral treatment\n  phoriz_bar(filter(pdfr_anc, strainID == \"HAMBI_1972\"), COG_category_long, cogpal) +\n  pheat_labs(filter(pdfr_anc, strainID == \"HAMBI_1972\"), freq_alt_complete) + \n  # evolved 1977\n  phoriz_bar(filter(pdfr_evo, strainID == \"HAMBI_1977\"), COG_category_long, cogpal) +\n  pheat_labs(filter(pdfr_evo, strainID == \"HAMBI_1977\"), freq_alt_complete) + \n  # evolved 1287\n  phoriz_bar(filter(pdfr_evo, strainID == \"HAMBI_1287\"), COG_category_long, cogpal) +\n  pheat_labs(filter(pdfr_evo, strainID == \"HAMBI_1287\"), freq_alt_complete) + \n  plot_layout(ncol = 1, nrow = 10,\n              heights = c(0.25, 1, 0.25, 1, 0.25, 1, 0.25, 1, 0.25, 1),\n              guides = \"collect\")\n\npheat_par\n\n\n\n\n\n\n\n\n\n\n4.1.2.1 Save\n\n\nShow/hide code\nggsave(here::here(figs, \"heatmap_par_alleles.svg\"), pheat_par, width=12, height=10, units=\"in\",\n       device=\"svg\")",
    "crumbs": [
      "Metagenome sequencing",
      "3. Variant plotting"
    ]
  },
  {
    "objectID": "R/metagenome/03_analyze_metagenome_variant_timeseries.html#individual-allelle-trajectories",
    "href": "R/metagenome/03_analyze_metagenome_variant_timeseries.html#individual-allelle-trajectories",
    "title": "Plot variant time series",
    "section": "4.2 Individual allelle trajectories",
    "text": "4.2 Individual allelle trajectories\nRead data from parallelism analysis\nFunction for plotting trajectories for indivdidual genes\n\n\nShow/hide code\nplotpargenes &lt;- function(strainID){\n  pdfr &lt;- left_join(par_genes, df2plot, \n          by = join_by(locus_tag, strainID, prey_history, predator_history, chrom)) %&gt;% \n  # to reduce size only include genes that are mutated in at least two of the replicates\n  filter(n_replicate &gt;=2) %&gt;% \n  # name the genes for plotting\n  mutate(gene_lab = if_else(is.na(gene), Preferred_name, gene),\n         treat = paste0(\"prey:\", prey_history, \" | pred:\", predator_history)) %&gt;% \n  mutate(gene_lab = if_else(gene_lab == \"-\", Description, gene_lab)) %&gt;% \n  filter(strainID == {{ strainID }})\n  \n  # make random color set to help differentiate alleles \n  mypal &lt;- unname(createPalette(length(unique(pdfr$mylab2)), c(\"#F3874AFF\", \"#FCD125FF\"), M=5000))\n  \n  ggplot() +\n  geom_line(data=pdfr[!is.na(pdfr$freq_alt_complete), ],\n            aes(x=time_days, y=freq_alt_complete,\n                group = mylab2,\n                color = hgvs_p)) +\n  geom_point(data = pdfr, \n             aes(x=time_days, y=freq_alt_complete, shape = replicate), \n             alpha = 1) +\n  guides(color = \"none\") +\n  scale_color_manual(values = mypal) + \n  facet_wrap(gene_lab ~ treat) +\n  labs(x = \"Days\", y = \"Allele frequency\") +\n  theme_bw() +\n  theme(\n    legend.position = \"bottom\",\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n    panel.grid = element_blank())\n}\n\n\n\n4.2.1 HAMBI_1287\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Nonsynonymous variant frequencies (vertical axis) over time (horizontal axis) for combinations of individual genes (title bar top row) and treatment combinations (title bar bottom row). Point shape denotes the biological replicate from the treatment and line colors indicate the amino acid changing variant (some genes have multiple non-synonymous variants at different positions). Focal genes are from Citrobacter koserii HAMBI_1287 and are those exhibiting significant parallelism for the duration of the experiment.\n\n\n\n\n\n4.2.2 HAMBI_1972\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: As in Figure 1 but for Aeromonas caviae HAMBI_1972.\n\n\n\n\n\n4.2.3 HAMBI_1977\n\n\n\n\n\nWarning: Removed 9 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: As in Figure 1 but for Pseudomonas chlororaphis HAMBI_1977.\n\n\n\n\n\n4.2.4 HAMBI_2659\n\n\n\n\n\nWarning: Removed 12 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: As in Figure 1 but for Stenotrophomonas maltophilia HAMBI_2659.\n\n\n\n\n\n4.2.5 Selection of parallel genes to plot\n\nShow/hide code\npdfr &lt;- par_genes %&gt;% \n  filter(n_replicate &gt;= 2) %&gt;% \n  arrange(desc(gene_multiplicity_m_i)) %&gt;% \n  # take top 20 highest multiplicitiies\n  slice(1:20) %&gt;% \n  left_join(df2plot, by = join_by(locus_tag, strainID, prey_history, predator_history, chrom)) %&gt;% \n  # name the genes for plotting\n  mutate(gene_lab = if_else(is.na(gene), Preferred_name, gene),\n         treat = paste0(\"prey:\", prey_history, \" | pred:\", predator_history)) %&gt;% \n  mutate(gene_lab = if_else(gene_lab == \"-\", Description, gene_lab))\n\n\nmypal &lt;- unname(createPalette(length(unique(pdfr$mylab2)), c(\"#F3874AFF\", \"#FCD125FF\"), M=5000))\n  \nggplot() +\n  geom_line(data=pdfr[!is.na(pdfr$freq_alt_complete), ],\n            aes(x=time_days, y=freq_alt_complete,\n                group = mylab2,\n                color = hgvs_p)) +\n  geom_point(data = pdfr, \n             aes(x=time_days, y=freq_alt_complete, shape = replicate), \n             alpha = 1) +\n  guides(color = \"none\") +\n  scale_color_manual(values = mypal) + \n  facet_wrap(gene_lab ~ treat) +\n  labs(x = \"Days\", y = \"Allele frequency\") +\n  theme_bw() +\n  theme(\n    legend.position = \"bottom\",\n    strip.placement = 'outside',\n    strip.background = element_blank(),\n    panel.grid = element_blank())\n\n\n\n\n\n\nWarning: Removed 11 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: As in Figure 1 but for the genes with the top 20 higest gene multiplicities across HAMBI_1287, HAMBI_1972, HAMBI_1977, and HAMBI_2659.",
    "crumbs": [
      "Metagenome sequencing",
      "3. Variant plotting"
    ]
  },
  {
    "objectID": "R/illumina_v3v4/01_rpkm2tab.html",
    "href": "R/illumina_v3v4/01_rpkm2tab.html",
    "title": "Process and format amplicon count data",
    "section": "",
    "text": "1 Setup\nLibraries and global variables\n\n\nShow/hide code\nlibrary(here)\nlibrary(tidyverse)\nlibrary(fs)\nlibrary(archive)\nsource(here::here(\"R\", \"utils_generic.R\"))\n\n\nSet up some directories\n\n\nShow/hide code\ndata_raw &lt;- here::here(\"_data_raw\", \"illumina_v3v4\")\namptar &lt;- here::here(data_raw, \"bbmap_rpkm.tar.gz\")\n\n# create temporary location to decompress\ntmpdir &lt;- fs::file_temp()\n\n# make processed data directory if it doesn't exist\ndata &lt;- here::here(\"data\", \"illumina_v3v4\")\nfs::dir_create(data)\n\n\nUntar and decompress\n\n\nShow/hide code\n# untar directory containing variant tables \narchive::archive_extract(\n  amptar,\n  dir = tmpdir,\n  files = NULL,\n  options = character(),\n  strip_components = 0L\n)\n\nampdir &lt;- here::here(tmpdir, \"bbmap_rpkm\")\n\n\n\n\n2 Reading and small formatting of data\nCoverage data\n\n\nShow/hide code\nampfiles &lt;- fs::dir_ls(\n  path = ampdir,\n  all = FALSE,\n  recurse = TRUE,\n  type = \"file\",\n  glob = \"*.rpkm\",\n  regexp = NULL,\n  invert = FALSE,\n  fail = TRUE\n)\n\nampslurped &lt;- readr::read_tsv(\n  ampfiles,\n  comment = \"#\",\n  col_names = c(\n    \"strainID\",\n    \"Length\",\n    \"Bases\",\n    \"Coverage\",\n    \"count\",\n    \"RPKM\",\n    \"Frags\",\n    \"FPKM\"\n  ),\n  col_types = \"cddddddd\",\n  id = \"file_name\"\n)\n\n\nformat the data nicely\n\n\nShow/hide code\nampslurpedfmt &lt;- ampslurped %&gt;%\n  mutate(sample = str_extract(file_name, \"HAMBI[:digit:]{4}\")) %&gt;%\n  left_join(tax, by = join_by(strainID)) %&gt;% \n  dplyr::select(sample, strainID, genus, species, count) %&gt;% \n  mutate(strainID = str_replace(strainID, \"-\", \"_\"))\n\n\ncleanup temporary directory\n\n\nShow/hide code\nfs::dir_delete(tmpdir)\n\n\n\n\nShow/hide code\nampslurpedfmtnrm &lt;- ampslurpedfmt %&gt;% \n  mutate(\n    count = case_when(\n      # trunc ensures we get integers. important for some alpha div measures\n      .$strainID == \"HAMBI_1842\" ~ trunc(.$count/4),\n      .$strainID == \"HAMBI_2659\" ~ trunc(.$count/2),\n      TRUE ~ as.numeric(.$count)\n    ))\n\n\n\n\n3 Export\n\n\nShow/hide code\nwrite_tsv(ampslurpedfmtnrm, here(data, \"species_counts.tsv\"))",
    "crumbs": [
      "Community composition amplicon",
      "1. Read and format"
    ]
  },
  {
    "objectID": "R/wgs/02_parallelism.html",
    "href": "R/wgs/02_parallelism.html",
    "title": "WGS genetic parallelism analysis",
    "section": "",
    "text": "Libraries and global variables\n\n\nShow/hide code\nlibrary(tidyverse)\nlibrary(here)\nlibrary(fs)\nlibrary(patchwork)\nlibrary(ggforce)\nlibrary(latex2exp)\nlibrary(vctrs)\n\nsource(here::here(\"R\", \"utils_generic.R\"))\nsource(here::here(\"R\", \"wgs\", \"utils_parallelism.R\"))\n\n\nSet up some directories\n\n\nShow/hide code\ndata_raw &lt;- here::here(\"_data_raw\", \"wgs\")\nshared &lt;- here::here(\"_data_raw\", \"shared\")\ndata &lt;- here::here(\"data\", \"wgs\")\nfigs &lt;- here::here(\"figs\", \"wgs\")\n\n# make processed data directory if it doesn't exist\nfs::dir_create(data)\nfs::dir_create(figs)",
    "crumbs": [
      "Population WGS",
      "2. Parallelism analysis"
    ]
  },
  {
    "objectID": "R/wgs/02_parallelism.html#nucleotide-parallelism-by-treatment",
    "href": "R/wgs/02_parallelism.html#nucleotide-parallelism-by-treatment",
    "title": "WGS genetic parallelism analysis",
    "section": "3.1 Nucleotide parallelism by treatment",
    "text": "3.1 Nucleotide parallelism by treatment\nHere we will do the estimation separately for each species \\(\\times\\) treatment combination.\n\n\nShow/hide code\nnuc_survival &lt;- mgvars_filt_mb %&gt;%\n  dplyr::select(strainID, pos, ref, alt, replicate) %&gt;% \n  # multiplicity = number of replicate populations each unique mutation is\n  # observed in group by the mutation position, with alternative allele to the\n  # grouping\n  summarize(m = n_distinct(replicate), .by = c(strainID, pos, ref, alt)) %&gt;%\n  # now calculate the total number of mutations across all replicates so we need\n  # to ungroup by mutation position/alt allele but because we still want to\n  # determine this value by treatment category we keep the treatment category\n  # grouping. However, this should be changed if you want to for example average\n  # over all the treatment conditions on a species basis\n  group_by(strainID) %&gt;%\n  count(m, name = \"m_count\") %&gt;%\n  mutate(n = m * m_count,\n         Ntot = sum(n),\n         perc = n / Ntot * 100) %&gt;%\n  left_join(genome_len, by = join_by(strainID)) %&gt;%\n  arrange(cur_group_id(), desc(m)) %&gt;%\n  #  dpois() tells the probability mass at a given number of counts. Here we\n  #  want to get the probability of observing n mutations with multiplicity\n  #  = mi (i.e. the counts of mi in the observed data). We assume that\n  #  mutations independently occur on the genome of size Ltot at a rate of\n  #  lambda = Ntot/Ltot and that generally the events are rare. Thus this\n  #  situation can be modeled by the Poisson distribution. We can get the\n  #  binned number of mutations per level of multiplicity m by multiplying\n  #  the probability by the length of the genome and the binned mutations\n  #  divided by the total number of mutations.\n  mutate(m_count_expected = cumsum((m_count / Ntot) *\n                                     total_len *\n                                     dpois(m, lambda = Ntot / total_len))) %&gt;%\n  dplyr::select(-num_contigs) %&gt;%\n  relocate(m, n, Ntot, perc, m_count, m_count_expected) %&gt;%\n  ungroup()\n\n# setup for plotting\nnuc_survival_plot &lt;- nuc_survival %&gt;% \n  group_by(strainID) %&gt;% \n  # when there is only one multiplicity observed for a mutation filter such\n  # that the multiplicty of that mutation must be greater than one.\n  # Otherwise include all remaining mutations (m &gt; 0)\n  filter(case_when(n() == 1 ~ m &gt; 1,\n                       TRUE ~ m &gt; 0)) %&gt;% \n  pivot_longer(cols = c(\"m_count\", \"m_count_expected\")) %&gt;% \n  mutate(label = paste(strainID)) %&gt;% \n  # and make final plot\n  plot_nuc_survival(., 5000, c(1, 10, 100, 1000, 10000), 4)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Distribution of nucleotide multiplicity \\((m_{i})\\) - i.e., the number of replicates with with the same genomic mutation including site and alternative allele - for each species with multiplicities \\(\\gt 1\\). The observed data is shown in blue while the null expectation is shown in red. In all cases the observed \\(m_{i}\\) exceeded the null expectation meaning that we must reject the simple null model of uniform mutation distribution in favor of the alternative model where mutations are nonrandom and cluster across replicate populations.",
    "crumbs": [
      "Population WGS",
      "2. Parallelism analysis"
    ]
  },
  {
    "objectID": "R/wgs/02_parallelism.html#conclusion",
    "href": "R/wgs/02_parallelism.html#conclusion",
    "title": "WGS genetic parallelism analysis",
    "section": "3.2 Conclusion",
    "text": "3.2 Conclusion\nNucleotide parallelism results are presented in Figure Figure 1. For these species this very simple null model mostly predicts that we should expect fewer than two parallel mutations (same position, same alternative allele) across the three replicate populations. For 12 evolved species the observed data show an excess of nucleotide parallelism relative to this simple null expectation. In particular HAMBI_0006, HAMBI_1287, and HAMBI_2494 all have at least 1 mutation that is identical across all three replicate evolved populations. However, multi-hit sites are only a very small fraction of the total observed mutations across all species (~ 3% across species with multi-hit sites). Thus, we will continue our analysis but looking at the gene level.\n\n\nShow/hide code\nnuc_survival %&gt;% \n  mutate(Ntot_f = sum(n)) %&gt;% \n  summarize(perc = sum(n)/Ntot_f*100, .by = \"m\") %&gt;% \n  distinct() %&gt;% \n  mutate(cum_perc = cumsum(perc))",
    "crumbs": [
      "Population WGS",
      "2. Parallelism analysis"
    ]
  },
  {
    "objectID": "R/wgs/02_parallelism.html#prepare-input-data-for-non-syn-mutations-only",
    "href": "R/wgs/02_parallelism.html#prepare-input-data-for-non-syn-mutations-only",
    "title": "WGS genetic parallelism analysis",
    "section": "4.1 Prepare input data for non-syn mutations only",
    "text": "4.1 Prepare input data for non-syn mutations only\n\n\nShow/hide code\nmgvars_filt_ns &lt;- mgvars_filt_mb %&gt;% \n  # exclude intragenic, intergenic, and synonymous mutations. Also exclude\n  # fusion functions because these are weird and also rare. Excluding the\n  # modifier category also ensures that we filter out any tRNAs with mutations\n  filter(!str_detect(effect, \"intergenic|intragenic|synonymous|fusion\")) %&gt;% \n  filter(!str_detect(impact, \"MODIFIER\")) %&gt;% \n  dplyr::select(strainID, replicate, chrom:alt, locus_tag) %&gt;% \n  relocate(strainID, locus_tag)",
    "crumbs": [
      "Population WGS",
      "2. Parallelism analysis"
    ]
  },
  {
    "objectID": "R/wgs/02_parallelism.html#g-score",
    "href": "R/wgs/02_parallelism.html#g-score",
    "title": "WGS genetic parallelism analysis",
    "section": "4.2 G score",
    "text": "4.2 G score\nWarning! this takes some time\n\n\nShow/hide code\nmuts_by_sp &lt;- mgvars_filt_ns %&gt;% \n  group_by(strainID) %&gt;% \n  distinct() %&gt;% \n  mutate(groupid = cur_group_id()) %&gt;%\n  group_by(groupid, strainID)\n\n# doing 10000 permutations\nresult_sp &lt;- run_full_gene_parallelism_pipeline(muts_by_sp, degentab, 10000)\n\n# Save this for later\nwrite_rds(result_sp, here::here(data, \"parallelism_results_sp_nomobile.rds\"))\n\n\n\n\nShow/hide code\n# Read in previous results\nresult_sp &lt;- read_rds(here::here(data, \"parallelism_results_sp_nomobile.rds\"))\n\n\n\n4.2.1 Simulating the number of replicates with a parallel gene hit\nAs another sanity check, we took the resamplings from the null distribution and calculated the number of replicates with a parallel gene hit (i.e. the same gene hit in \\(\\geq 2\\) experimental replicates) and compared that to the observed distribution. The null distribution reflected the process of sampling a mutation under a multinomial distribution with probability proportional to the total number of nonsynonymous sites \\(L_{i}\\) in \\(gene_{i}\\). We observed that in 9/16 cases the null distribution produced fewer parallel gene hits than observed in the data from 2 experimental replicates. In all 16 cases the null distribution produced fewer parallel gene hits than observed in the data from 3 experimental replicates. Thus, for some suspicious genes with very high mutational density (see below) we required these genes to be present in all three replicates to include them in our final significant gene lists.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Number of genes (y axis) with nonsynonymous mutation hits in \\(N_{replicates} = \\{n : 1 \\leq n \\leq 3\\}\\) (x axis). Blue bars depict the distribution observed in the data, while red bars depict the null distribution from resampling mutations to the observed \\(n_{tot}\\) set size from each species using the multinomial distribution, where the probability of sampling a non-synonymous mutation at \\(gene_{i}\\) was dependent only on the number of nonsynonymous sites in the gene.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Same as in Figure 2 but for different treatment combinations.\n\n\n\n\n\n4.2.2 Visualize the survival curves for each treatment combination\n\n\nShow/hide code\nsurvcurv &lt;- result_sp$output_df2plot %&gt;% \n  filter(!is.na(xend)) %&gt;% \n  mutate(label = strainID) %&gt;% \n  ggplot() +\n    geom_segment(\n      aes(\n        x = x,\n        y = y,\n        xend = xend,\n        yend = yend\n      ),\n      linetype = \"dashed\",\n      linewidth = 0.25, color = \"red\"\n    ) +\n    geom_step( aes(x = obs_p, y = value, color = name)) +\n    facet_wrap(~ label, ncol = 4) +\n    labs(x = TeX(\"$-log_{10}P$\"), y = \"Number of genes\") +\n    scale_color_manual(values = c(\"blue\", \"grey50\")) +\n    scale_y_log10(\n      breaks = c(1, 10, 100),\n      labels = scales::trans_format(\"log10\", scales::math_format(10 ^.x))\n    ) +\n    annotation_logticks(sides = \"l\", color = \"grey40\") +\n    coord_cartesian(ylim = c(1, 200)) +\n    theme_bw() +\n    theme(\n      strip.background = element_blank(),\n      panel.grid = element_blank(),\n      legend.position = \"bottom\"\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: The observed \\((N)\\) (blue line) and expected number \\((\\overline{N})\\) (grey line) of genes with \\(P_{i} \\leq P\\), as a function of \\(P\\). The red dashed line denotes the genome-wide significance threshold \\(P^{*}\\) for \\(\\alpha = 0.05\\) defined in Equation Equation 6.\n\n\n\n\n\n4.2.3 Inspecting individual genes\n\n\nShow/hide code\nresult_sp$output_gscore %&gt;% \n  filter(pvalue &lt;= 0.05)\n\n\n\n  \n\n\n\nAlso some genes tend to have a large number of consecutive mutations which is probably due to incorrect read mapping and not real mutations so we will try and filter these out. We’ll do this by filtering on genes with a mutational density \\(d_{g} \\gt 0.15\\), where the mutational density in gene \\(g\\) was defined as\n\\[d_{g} = \\frac{|A|_{g}}{b_{g} - a_{g}}\\]\nfor all genome positions \\(x\\) on the interval \\(\\{x | a_{g} \\leq x \\leq b_{g}\\}\\) where \\(b_{g}\\) is the greatest position and \\(a_{g}\\) is the smallest position of observed mutations in gene \\(g\\) and \\(|A|_{g}\\) is the cardinality of the mutation set.\n\n\nShow/hide code\nhigh_density_genes &lt;- mgvars_filt_ns %&gt;% \n  group_by(strainID, locus_tag, replicate) %&gt;% \n  mutate(mutwindox = pos - lag(pos),\n         mut_num = n(),\n         mut_dens = n()/(max(pos) -  min(pos))) %&gt;% \n  ungroup() %&gt;% \n  filter(mut_dens != Inf) %&gt;% \n  filter(mut_dens &gt; 0.15) %&gt;% \n  distinct(locus_tag) %&gt;% \n  pull()\n\n\n\n\nShow/hide code\noutput_gene_table_filt &lt;- result_sp$output_gene_table %&gt;% \n  # only genes exceeding the critical pstar value from the survival curves above\n  filter(neg_log10P &gt;= pstar) %&gt;% \n  # only include genes with at least 3 hits in the same gene or found in more than one replicate.\n  filter(observed_hits_n_i &gt;= 3 | n_replicate &gt; 1) %&gt;%\n  # filters out the problematic genes above unless the number of replicates detected is 2 or more\n  filter(case_when(n_replicate &lt; 2 ~ !(locus_tag %in% high_density_genes), \n                   TRUE ~ n_replicate &gt; 1)) %&gt;% \n  left_join(distinct(select(mgvars_filt, locus_tag, product, cds_length:gene)),\n            by = join_by(locus_tag))\n\noutput_gene_table_filt",
    "crumbs": [
      "Population WGS",
      "2. Parallelism analysis"
    ]
  },
  {
    "objectID": "R/wgs/02_parallelism.html#all-species",
    "href": "R/wgs/02_parallelism.html#all-species",
    "title": "WGS genetic parallelism analysis",
    "section": "5.1 All species",
    "text": "5.1 All species\nCalculate the probability of each gene (ns_sites/total_ns_sites) and link to COG categories\n\n\nShow/hide code\neggnog_nslen &lt;- left_join(eggnog, degentab,\n                          by = join_by(strainID, locus_tag)) %&gt;% \n  dplyr::select(strainID, locus_tag, COG_category_single, ns_length) %&gt;% \n  filter(!is.na(COG_category_single)) %&gt;% \n  group_by(strainID) %&gt;% \n  mutate(p = ns_length/sum(ns_length), \n         cog_genes = n()) %&gt;% \n  ungroup()\n\n\n\n5.1.1 Jensen Shannon Divergence\nThis function draws n genes from each species with a probability proportional to gene length, where n = the number of significant parallel genes observed from the data. We repeat this simulation 10 000 times and below we check if 1) the Jensen Shannon divergence between the distribution of the COG categories drawn randomly and the background (i.e., the distribution of COG categories in the whole genome) is greater than the Jensen Shannon divergence between the background and the observed distribution of COG categories in significantly parallel genes. The idea is that if some COG categories are enriched/depleted in the parallel genes, then the JSD divergence between the observed and the background should be larger than the JSD between the random sampled genes (sampling probability based only on gene length) and the background. We calculate an empirical P value by “counting” how many times the simulated JSD exceeds the observed.\n\n\nShow/hide code\ngene_draw &lt;- function(){\n  output_gene_table_filt %&gt;%\n    group_by(strainID) %&gt;%\n    summarize(nsiggenes = n()) %&gt;%\n    left_join(eggnog_nslen,\n              by = join_by(strainID)) %&gt;%\n    nest(data = -c(strainID)) %&gt;%\n    mutate(locus_tag = map(\n      data,\n      \\(x) sample(\n        x = x$locus_tag,\n        size = unique(x$nsiggenes),\n        prob = x$p,\n        replace = FALSE\n      )\n    )) %&gt;%\n    dplyr::select(-data) %&gt;%\n    unnest(cols = locus_tag) \n}\n\n# take 10 000 random draws of the genes. Use a seed for reproducibility\nwithr::with_seed(12367,\n                 genes_simulated &lt;- map(1:10000, ~gene_draw(), .progress=TRUE) %&gt;% \n                   list_rbind(names_to = \"id\"))\n\n# save the output so we don't need to run again\nwrite_rds(genes_simulated, here::here(data, \"genes_simulated_nomobile.rds\"))\n\n\nSome data formatting\n\n\nShow/hide code\n# read data back\ngenes_simulated &lt;- read_rds(here::here(data, \"genes_simulated_nomobile.rds\"))\n\n# map the locus_tags to COG categories for the simulated\n# gene draws\nCOGs_distribution_simulated &lt;- genes_simulated %&gt;%\n  left_join(eggnog_nslen, by = join_by(strainID, locus_tag)) %&gt;%\n  group_by(id) %&gt;% \n  count(COG_category_single, name = \"nsim\") %&gt;% \n  ungroup()\n\n# get the discrete distribution of COGs in the significant parallel genes\nCOGs_distribution_observed &lt;- left_join(output_gene_table_filt, eggnog,\n                                        by = join_by(locus_tag, strainID)) %&gt;% \n  count(COG_category_single, name = \"nobs\") \n\n# get the discrete distribution of COGs across the whole genome of all species\n# this is the null case (i.e. the background that we would expect if there was no\n# enrichment)\nCOGs_distribution_nullexpectation &lt;- eggnog %&gt;% \n  count(COG_category_single, name = \"nnull\") \n\n\nNow we calculate the Jensen Shannon divergence between the background and the simulated data to estimate an empirical P value\n\n\nShow/hide code\n# function to calculate the Jensen Shannon divergene of a pair of\n# distributions\nJSD_pair &lt;- function(p, q){\n  m &lt;- 0.5 * (p + q)\n  JS &lt;-  0.5 * (sum(p * log(p/m)) + sum(q * log(q/m)))\n  return(JS)\n}\n\n# Calculate the Jensen Shannon divergence between the COG distribution observed in \n# enriched genes and the COG distribution in the genomic background\nJSD_observed &lt;- left_join(COGs_distribution_observed, COGs_distribution_nullexpectation,\n                          by = join_by(COG_category_single)) %&gt;% \n  mutate(p = nobs/sum(nobs), \n         q = nnull/sum(nnull)) %&gt;% \n  summarize(JSD = JSD_pair(p, q)) %&gt;% \n  pull()\n\n# now calculate JSD between the simulated draws and the backgound distribution\nJSD_simulated &lt;- left_join(COGs_distribution_simulated, \n                           COGs_distribution_nullexpectation,\n                           by = join_by(COG_category_single)) %&gt;% \n  # drops from calculation categories that aren't in both the observed data\n  # and the resampled data. Need to do this because JSD can't handle zero values\n  drop_na() %&gt;% \n  group_by(id) %&gt;% \n  mutate(p = nsim/sum(nsim), \n         q = nnull/sum(nnull)) %&gt;%\n  summarize(JSD = JSD_pair(p, q)) %&gt;% \n  pull(JSD)\n\n# proportion of JSD measures between simulated and the background that are greater\n# than the JSD between the observed and the background\nglobal_p &lt;- length(JSD_simulated[JSD_simulated &gt;= JSD_observed])/length(JSD_simulated)\n\nglobal_p\n\n\n[1] 0.397\n\n\n\n\n5.1.2 Enrichment of individual COG categories\nOK so the overall distribution of COG categories in the parallel genes is not significantly different than in the rest of the genome - ~40% of the time the JSD between the COG distribution in a random sample and the background is greater than the observed COG distribution and the background.\n\n5.1.2.1 Hypergeometric Test\nWe can test enrichment in individual COG categories in individual species using the hypergeometric test\n\n\nShow/hide code\nlibrary(qvalue)\n\npar2test &lt;- left_join(output_gene_table_filt, eggnog,\n                      by = join_by(locus_tag, strainID)) %&gt;%\n  filter(!is.na(COG_category)) %&gt;% \n  group_by(strainID) %&gt;% \n  count(COG_category_single, name = \"n_cog_par\") %&gt;% \n  mutate(n_par = sum(n_cog_par))\n\nback2test &lt;- eggnog %&gt;% \n  filter(!is.na(COG_category)) %&gt;% \n  group_by(strainID) %&gt;% \n  count(COG_category_single, name = \"n_cog_background\") %&gt;% \n  mutate(n_background = sum(n_cog_background))\n\nphypres &lt;- left_join(par2test, back2test, by = join_by(strainID, COG_category_single)) %&gt;% \n  mutate(p_enrich = enricher(n_background, n_par, n_cog_background, n_cog_par, over=TRUE),\n         p_deplete = enricher(n_background, n_par, n_cog_background, n_cog_par, over=FALSE)) %&gt;% \n  mutate(p_enrich_adj = p.adjust(p_enrich, method = \"fdr\"),\n         p_deplete_adj = p.adjust(p_deplete, method = \"fdr\")) %&gt;% \n  arrange(p_enrich_adj)\n\nqenrich &lt;- qvalue_truncp(phypres$p_enrich)\nqdeplete &lt;- qvalue_truncp(phypres$p_deplete)\n\nphypres$q_enrich &lt;- qenrich$qvalues\nphypres$q_deplete &lt;- qdeplete$qvalues\n\nphypres %&gt;% \n  relocate(p_enrich, q_enrich, p_enrich_adj) %&gt;% \n  arrange(p_enrich)\n\n\n\n  \n\n\n\nHere COG categories “D - Cell cycle control, cell division, chromosome partitioning”, “M - Cell wall/membrane/envelope biogenesis”, and “P - Inorganic ion transport and metabolism” are enriched with \\(p_{adj} \\leq 0.05\\).\n\n\n5.1.2.2 Nonparametric simulation\nWe can also look at different COG categories by simply counting the number of random samplings that have a COG count greater/less than that the observed COG count. Since we resampled the same number of genes as in the observed we can compare the two directly. Below we do this integrated over all species in the community to see if there was any pathway enriched across all species.\n\n\nShow/hide code\nleft_join(COGs_distribution_simulated, COGs_distribution_observed,\n          by = join_by(COG_category_single)) %&gt;% \n  drop_na() %&gt;% \n  mutate(gt = if_else(nsim &gt;= nobs, 1, 0)) %&gt;% \n  group_by(COG_category_single) %&gt;% \n  summarize(p = sum(gt)/n()) %&gt;% \n  arrange(p) %&gt;% \n  mutate(p_adj = p.adjust(p, method = \"fdr\"))\n\n\n\n  \n\n\n\nOnly about 1% of the re-samples had a higher number of K COG genes compared to the observed number of K COG genes. No other COG category meets the standard alpha = 0.05 threshold. However, after correcting for multiple testing the 5% alpha threshold is no longer met.\nThis is just a sanity check that the randomly sampled COGs reflect the background distribution - i.e., a large fraction of the resamples are larger (and smaller) than the null. There is no systematic difference, and we observe the different COG categories in the resampels at basically the same rate as we observe the COG categories in the background.\n\n\nShow/hide code\nleft_join(COGs_distribution_simulated, COGs_distribution_nullexpectation,\n          by = join_by(COG_category_single)) %&gt;%\n  group_by(id) %&gt;% \n  mutate(fsim = nsim/sum(nsim), fnull = nnull/sum(nnull)) %&gt;% \n  drop_na() %&gt;% \n  mutate(gt = if_else(fsim &gt;= fnull, 1, 0)) %&gt;% \n  group_by(COG_category_single) %&gt;% \n  summarize(p = sum(gt)/n()) %&gt;% \n  arrange(p)\n\n\n\n  \n\n\n\n\n\n\n5.1.3 COG Distribution Plot\n\n\nShow/hide code\ncog_pmut &lt;- left_join(output_gene_table_filt, eggnog,\n                      by = join_by(locus_tag, strainID)) %&gt;% \n  count(COG_category_single) %&gt;% \n  mutate(f = n/sum(n),\n         n = n*1000,\n         type = \"parallel_mutations\") \n\ncog_everything &lt;- eggnog %&gt;% \n  count(COG_category_single) %&gt;% \n  mutate(f = n/sum(n), \n         type = \"all_genes\") \n\npcogs &lt;- bind_rows(cog_pmut, cog_everything) %&gt;% \n  drop_na() %&gt;% \n  ggplot() +\n  geom_bar(aes(x = fct_reorder(COG_category_single, f, .desc = F), y=n, fill = type), stat=\"identity\",\n           position = position_dodge( preserve = \"total\")) +\n  scale_fill_brewer(palette = \"Set1\") +\n  labs(x = \"COG Category\", y = \"Fraction genes in COG category\", fill = \"Subset\") +\n  scale_y_continuous(\n    \"N all genes\", \n    sec.axis = sec_axis(~ . * 1/1000, name = \"N parallel genes\")\n  ) +\n  theme_bw() + \n  theme(\n    panel.grid = element_blank(),\n    panel.background = element_blank(),\n    legend.position = \"bottom\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Number of genes in each Cluster of Orthologous Groups (COG) category for genes with a COG annotation across all 23 HAMBI population genomes (red bars, left y-axis) and across only genes exhibiting significant genomic parallelism (blue bars, right y-axis).",
    "crumbs": [
      "Population WGS",
      "2. Parallelism analysis"
    ]
  },
  {
    "objectID": "R/wgs/02_parallelism.html#species-present-in-the-metagenomes",
    "href": "R/wgs/02_parallelism.html#species-present-in-the-metagenomes",
    "title": "WGS genetic parallelism analysis",
    "section": "5.2 Species present in the metagenomes",
    "text": "5.2 Species present in the metagenomes\nNow that I’ve done the analysis on the metagenomes we know that we can only detect HAMBI_2659, HAMBI_1972, HAMBI_1977, and HAMBI_1287 with high enough coverate to detect sequence variants. From the hypergeometric test above we know that COG categories D, M, and P are enriched in HAMBI_1972, HAMBI_1977, amd HAMBI_2659 respsectively. Here we will make a plot focusing only on those species\n\n\nShow/hide code\n# species detected in the metagenomes\nmgsp &lt;- c(\"HAMBI_2659\", \"HAMBI_1972\", \"HAMBI_1977\", \"HAMBI_1287\", \"HAMBI_2443\")\n\ncog_pmut_mgsp &lt;- left_join(output_gene_table_filt, eggnog,\n                      by = join_by(locus_tag, strainID)) %&gt;% \n  filter(strainID %in% mgsp) %&gt;% \n  group_by(strainID) %&gt;% \n  count(COG_category_single, name = \"tot\") %&gt;% \n  # scaling factor to make ploting on 2 axes possible\n  mutate(n = tot*250,\n         f = n/sum(n),\n         type = \"parallel_mutations\") \n\ncog_everything_mgsp &lt;- eggnog %&gt;% \n  filter(strainID %in% mgsp) %&gt;% \n  group_by(strainID) %&gt;% \n  count(COG_category_single) %&gt;% \n  mutate(f = n/sum(n),\n         type = \"all_genes\") \n\npcogs_mgsp &lt;- bind_rows(cog_pmut_mgsp, cog_everything_mgsp) %&gt;% \n  filter(!is.na(COG_category_single)) %&gt;% \n  ggplot() +\n  geom_bar(aes(x = fct_reorder(COG_category_single, n, .desc = F), y=n, fill = type), stat=\"identity\",\n           position = position_dodge( preserve = \"total\")) +\n  scale_fill_brewer(palette = \"Set1\") +\n  geom_point(data = tibble(x = c(\"D\", \"M\", \"M\", \"P\"), \n                           y = c(700, 700, 700, 700), \n                           strainID = c(\"HAMBI_1972\", \"HAMBI_1977\", \"HAMBI_2443\", \"HAMBI_2659\")),\n             aes(x = x, y = y), shape = 8) +\n  facet_wrap(~ strainID, nrow = 2) +\n  labs(x = \"COG Category\", y = \"Fraction genes in COG category\", fill = \"Subset\") +\n  scale_y_continuous(\n    \"N all genes\", \n    sec.axis = sec_axis(~ . * 1/250, name = \"N parallel genes\")\n  ) +\n  theme_bw() + \n  theme(\n    panel.grid = element_blank(),\n    strip.background = element_blank(),\n    panel.background = element_blank(),\n    legend.position = \"bottom\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Fraction of genes in each Cluster of Orthologous Groups (COG) category for genes with a COG annotation (red bars, left y-axis) and only genes exhibiting significant genomic parallelism (blue bars, right y-axis) for the four most abundant HAMBI genomes. COG categories “D - Cell cycle control, cell division, chromosome partitioning” for HAMBI_1972, “M - Cell wall/membrane/envelope biogenesis” for HAMBI_1977, and “P - Inorganic ion transport and metabolism” for HAMBI_2659 are significantly enriched (denoted with *) in the parallel mutations compared to the rest of the genome for these species.\n\n\n\n\n\nShow/hide code\nggsave(here::here(figs, \"COG_enrich_wgs.svg\"), pcogs_mgsp, width=7, height=5, \n       units=\"in\", device=\"svg\")\n\n\n\n\n\n\n\n\n\n\n\nstrainID\nAbundant in metagenomes\nCOG category\nq value\n\n\n\n\nHAMBI_1972\nyes\nD - Cell cycle control, cell division, chromosome partitioning\n0.006\n\n\nHAMBI_2443\nno\nM - Cell wall/membrane/envelope biogenesis\n0.013\n\n\nHAMBI_1977\nyes\nM - Cell wall/membrane/envelope biogenesis\n0.015\n\n\nHAMBI_2659\nyes\nP - Inorganic ion transport and metabolism\n0.031",
    "crumbs": [
      "Population WGS",
      "2. Parallelism analysis"
    ]
  }
]